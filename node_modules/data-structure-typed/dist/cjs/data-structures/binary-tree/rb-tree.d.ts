/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import { BinaryTreeDeleteResult, BTNCallback, BTNExemplar, BTNKeyOrNode, IterationType, RBTNColor, RBTreeOptions, RedBlackTreeNested, RedBlackTreeNodeNested } from '../../types';
import { BST, BSTNode } from './bst';
import { IBinaryTree } from '../../interfaces';
export declare class RedBlackTreeNode<K = any, V = any, N extends RedBlackTreeNode<K, V, N> = RedBlackTreeNodeNested<K, V>> extends BSTNode<K, V, N> {
    color: RBTNColor;
    constructor(key: K, value?: V, color?: RBTNColor);
}
/**
 * 1. Each node is either red or black.
 * 2. The root node is always black.
 * 3. Leaf nodes are typically Sentinel nodes and are considered black.
 * 4. Red nodes must have black children.
 * 5. Black balance: Every path from any node to each of its leaf nodes contains the same number of black nodes.
 */
export declare class RedBlackTree<K = any, V = any, N extends RedBlackTreeNode<K, V, N> = RedBlackTreeNode<K, V, RedBlackTreeNodeNested<K, V>>, TREE extends RedBlackTree<K, V, N, TREE> = RedBlackTree<K, V, N, RedBlackTreeNested<K, V, N>>> extends BST<K, V, N, TREE> implements IBinaryTree<K, V, N, TREE> {
    Sentinel: N;
    /**
     * This is the constructor function for a Red-Black Tree data structure in TypeScript, which
     * initializes the tree with optional elements and options.
     * @param [elements] - The `elements` parameter is an optional iterable of `BTNExemplar<K, V, N>`
     * objects. It represents the initial elements that will be added to the RBTree during its
     * construction. If this parameter is provided, the `addMany` method is called to add all the
     * elements to the
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the RBTree. It is of type `Partial<RBTreeOptions>`, which means that you can provide
     * only a subset of the properties defined in the `RBTreeOptions` interface.
     */
    constructor(elements?: Iterable<BTNExemplar<K, V, N>>, options?: Partial<RBTreeOptions<K>>);
    protected _root: N;
    get root(): N;
    protected _size: number;
    get size(): number;
    /**
     * The function creates a new Red-Black Tree node with the specified key, value, and color.
     * @param {K} key - The key parameter is the key value associated with the node. It is used to
     * identify and compare nodes in the Red-Black Tree.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the node. It is of type `V`, which is a generic type that can be replaced with any
     * specific type when using the `createNode` method.
     * @param {RBTNColor} color - The "color" parameter is used to specify the color of the node in a
     * Red-Black Tree. It can be either "RED" or "BLACK". By default, the color is set to "BLACK".
     * @returns The method is returning a new instance of a RedBlackTreeNode with the specified key,
     * value, and color.
     */
    createNode(key: K, value?: V, color?: RBTNColor): N;
    /**
     * The function creates a Red-Black Tree with the specified options and returns it.
     * @param {RBTreeOptions} [options] - The `options` parameter is an optional object that can be
     * passed to the `createTree` function. It is used to customize the behavior of the `RedBlackTree`
     * class.
     * @returns a new instance of a RedBlackTree object.
     */
    createTree(options?: RBTreeOptions<K>): TREE;
    /**
     * The function checks if an exemplar is an instance of the RedBlackTreeNode class.
     * @param exemplar - The `exemplar` parameter is of type `BTNExemplar<K, V, N>`.
     * @returns a boolean value indicating whether the exemplar is an instance of the RedBlackTreeNode
     * class.
     */
    isNode(exemplar: BTNExemplar<K, V, N>): exemplar is N;
    /**
     * The function "isNotNodeInstance" checks if a potential key is a K.
     * @param {any} potentialKey - The potentialKey parameter is of type any, which means it can be any
     * data type.
     * @returns a boolean value indicating whether the potentialKey is of type number or not.
     */
    isNotNodeInstance(potentialKey: BTNKeyOrNode<K, N>): potentialKey is K;
    /**
     * The function `exemplarToNode` takes an exemplar and converts it into a node object if possible.
     * @param exemplar - The `exemplar` parameter is of type `BTNExemplar<K, V, N>`, where:
     * @param {V} [value] - The `value` parameter is an optional value that can be passed to the
     * `exemplarToNode` function. It represents the value associated with the exemplar node. If a value
     * is provided, it will be used when creating the new node. If no value is provided, the new node
     * @returns a node of type N or undefined.
     */
    exemplarToNode(exemplar: BTNExemplar<K, V, N>, value?: V): N | undefined;
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     *
     * The `add` function adds a new node to a binary search tree and performs necessary rotations and
     * color changes to maintain the red-black tree properties.
     * @param keyOrNodeOrEntry - The `keyOrNodeOrEntry` parameter can be either a key, a node, or an
     * entry.
     * @param {V} [value] - The `value` parameter represents the value associated with the key that is
     * being added to the binary search tree.
     * @returns The method `add` returns either the newly added node (`N`) or `undefined`.
     */
    add(keyOrNodeOrEntry: BTNExemplar<K, V, N>, value?: V): N | undefined;
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a node from a binary tree based on a given identifier and updates
     * the tree accordingly.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * that you want to use to identify the node that you want to delete from the binary tree. It can be
     * of any type that is returned by the callback function `C`. It can also be `null` or `undefined` if
     * you don't want to
     * @param {C} callback - The `callback` parameter is a function that takes a node of type `N` and
     * returns a value of type `ReturnType<C>`. It is used to determine if a node should be deleted based
     * on its identifier. The `callback` function is optional and defaults to `this._defaultOneParam
     * @returns an array of `BinaryTreeDeleteResult<N>`.
     */
    delete<C extends BTNCallback<N>>(identifier: ReturnType<C> | null | undefined, callback?: C): BinaryTreeDeleteResult<N>[];
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    isRealNode(node: N | undefined): node is N;
    getNode<C extends BTNCallback<N, K>>(identifier: K, callback?: C, beginRoot?: N | undefined, iterationType?: IterationType): N | undefined;
    getNode<C extends BTNCallback<N, N>>(identifier: N | undefined, callback?: C, beginRoot?: N | undefined, iterationType?: IterationType): N | undefined;
    getNode<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback: C, beginRoot?: N | undefined, iterationType?: IterationType): N | undefined;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function returns the predecessor of a given node in a red-black tree.
     * @param {RedBlackTreeNode} x - The parameter `x` is of type `RedBlackTreeNode`, which represents a node in a
     * Red-Black Tree.
     * @returns the predecessor of the given RedBlackTreeNode 'x'.
     */
    getPredecessor(x: N): N;
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    clear(): void;
    protected _setRoot(v: N): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function performs a left rotation on a binary tree node.
     * @param {RedBlackTreeNode} x - The parameter `x` is of type `N`, which likely represents a node in a binary tree.
     */
    protected _leftRotate(x: N): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function performs a right rotation on a red-black tree node.
     * @param {RedBlackTreeNode} x - x is a RedBlackTreeNode, which represents the node that needs to be right
     * rotated.
     */
    protected _rightRotate(x: N): void;
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     *
     * The function `_fixDelete` is used to fix the red-black tree after a node deletion.
     * @param {RedBlackTreeNode} x - The parameter `x` represents a node in a Red-Black Tree (RBT).
     */
    protected _fixDelete(x: N): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_rbTransplant` replaces one node in a red-black tree with another node.
     * @param {RedBlackTreeNode} u - The parameter "u" represents a RedBlackTreeNode object.
     * @param {RedBlackTreeNode} v - The parameter "v" is a RedBlackTreeNode object.
     */
    protected _rbTransplant(u: N, v: N): void;
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n) on average (where n is the number of nodes in the tree)
     * Space Complexity: O(1)
     *
     * The `_fixInsert` function is used to fix the red-black tree after an insertion operation.
     * @param {RedBlackTreeNode} k - The parameter `k` is a RedBlackTreeNode object, which represents a node in a
     * red-black tree.
     */
    protected _fixInsert(k: N): void;
    /**
     * The function replaces an old node with a new node while preserving the color of the old node.
     * @param {N} oldNode - The `oldNode` parameter represents the node that needs to be replaced in a
     * data structure. It is of type `N`, which is the type of the nodes in the data structure.
     * @param {N} newNode - The `newNode` parameter is the node that will replace the `oldNode` in the
     * data structure.
     * @returns The method is returning the result of calling the `_replaceNode` method from the
     * superclass, passing in the `oldNode` and `newNode` as arguments.
     */
    protected _replaceNode(oldNode: N, newNode: N): N;
}
