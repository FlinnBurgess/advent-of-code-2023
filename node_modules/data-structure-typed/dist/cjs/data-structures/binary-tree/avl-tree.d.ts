/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import { BST, BSTNode } from './bst';
import type { AVLTreeNested, AVLTreeNodeNested, AVLTreeOptions, BinaryTreeDeleteResult, BSTNKeyOrNode, BTNCallback, BTNExemplar, BTNKeyOrNode } from '../../types';
import { IBinaryTree } from '../../interfaces';
export declare class AVLTreeNode<K = any, V = any, N extends AVLTreeNode<K, V, N> = AVLTreeNodeNested<K, V>> extends BSTNode<K, V, N> {
    height: number;
    constructor(key: K, value?: V);
}
/**
 * 1. Height-Balanced: Each node's left and right subtrees differ in height by no more than one.
 * 2. Automatic Rebalancing: AVL trees rebalance themselves automatically during insertions and deletions.
 * 3. Rotations for Balancing: Utilizes rotations (single or double) to maintain balance after updates.
 * 4. Order Preservation: Maintains the binary search tree property where left child values are less than the parent, and right child values are greater.
 * 5. Efficient Lookups: Offers O(log n) search time, where 'n' is the number of nodes, due to its balanced nature.
 * 6. Complex Insertions and Deletions: Due to rebalancing, these operations are more complex than in a regular BST.
 * 7. Path Length: The path length from the root to any leaf is longer compared to an unbalanced BST, but shorter than a linear chain of nodes.
 */
export declare class AVLTree<K = any, V = any, N extends AVLTreeNode<K, V, N> = AVLTreeNode<K, V, AVLTreeNodeNested<K, V>>, TREE extends AVLTree<K, V, N, TREE> = AVLTree<K, V, N, AVLTreeNested<K, V, N>>> extends BST<K, V, N, TREE> implements IBinaryTree<K, V, N, TREE> {
    /**
     * The constructor function initializes an AVLTree object with optional elements and options.
     * @param [elements] - The `elements` parameter is an optional iterable of `BTNExemplar<K, V, N>`
     * objects. It represents a collection of elements that will be added to the AVL tree during
     * initialization.
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the AVL tree. It is of type `Partial<AVLTreeOptions>`, which means that you can
     * provide only a subset of the properties defined in the `AVLTreeOptions` interface.
     */
    constructor(elements?: Iterable<BTNExemplar<K, V, N>>, options?: Partial<AVLTreeOptions<K>>);
    /**
     * The function creates a new AVL tree node with the specified key and value.
     * @param {K} key - The key parameter is the key value that will be associated with
     * the new node. It is used to determine the position of the node in the binary search tree.
     * @param [value] - The parameter `value` is an optional value that can be assigned to the node. It is of
     * type `V`, which means it can be any value that is assignable to the `value` property of the
     * node type `N`.
     * @returns a new AVLTreeNode object with the specified key and value.
     */
    createNode(key: K, value?: V): N;
    /**
     * The function creates a new AVL tree with the specified options and returns it.
     * @param {AVLTreeOptions} [options] - The `options` parameter is an optional object that can be
     * passed to the `createTree` function. It is used to customize the behavior of the AVL tree that is
     * being created.
     * @returns a new AVLTree object.
     */
    createTree(options?: AVLTreeOptions<K>): TREE;
    /**
     * The function checks if an exemplar is an instance of AVLTreeNode.
     * @param exemplar - The `exemplar` parameter is of type `BTNExemplar<K, V, N>`.
     * @returns a boolean value indicating whether the exemplar is an instance of the AVLTreeNode class.
     */
    isNode(exemplar: BTNExemplar<K, V, N>): exemplar is N;
    /**
     * The function "isNotNodeInstance" checks if a potential key is a K.
     * @param {any} potentialKey - The potentialKey parameter is of type any, which means it can be any
     * data type.
     * @returns a boolean value indicating whether the potentialKey is of type number or not.
     */
    isNotNodeInstance(potentialKey: BTNKeyOrNode<K, N>): potentialKey is K;
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The add method of the superclass (BST) has logarithmic time complexity.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     */
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The add method of the superclass (BST) has logarithmic time complexity.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     *
     * The function overrides the add method of a binary tree node and balances the tree after inserting
     * a new node.
     * @param keyOrNodeOrEntry - The `keyOrNodeOrEntry` parameter can be either a key, a node, or an
     * entry.
     * @param {V} [value] - The `value` parameter represents the value associated with the key that is
     * being added to the binary tree.
     * @returns The method is returning either the inserted node or undefined.
     */
    add(keyOrNodeOrEntry: BTNExemplar<K, V, N>, value?: V): N | undefined;
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The add method of the superclass (BST) has logarithmic time complexity.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     */
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The delete method of the superclass (BST) has logarithmic time complexity.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     *
     * The function overrides the delete method of a binary tree, performs the deletion, and then
     * balances the tree if necessary.
     * @param identifier - The `identifier` parameter is the value or condition used to identify the
     * node(s) to be deleted from the binary tree. It can be of any type and is the return type of the
     * `callback` function.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node
     * that is deleted from the binary tree. It is an optional parameter and if not provided, it will
     * default to the `_defaultOneParamCallback` function. The `callback` function should have a single
     * parameter of type `N
     * @returns The method is returning an array of `BinaryTreeDeleteResult<N>`.
     */
    delete<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback?: C): BinaryTreeDeleteResult<N>[];
    /**
     * The `_swapProperties` function swaps the key, value, and height properties between two nodes in a binary
     * tree.
     * @param {K | N | undefined} srcNode - The `srcNode` parameter represents the source node that
     * needs to be swapped with the destination node. It can be of type `K`, `N`, or `undefined`.
     * @param {K | N  | undefined} destNode - The `destNode` parameter represents the destination
     * node where the values from the source node will be swapped to.
     * @returns either the `destNode` object if both `srcNode` and `destNode` are defined, or `undefined`
     * if either `srcNode` or `destNode` is undefined.
     */
    protected _swapProperties(srcNode: BSTNKeyOrNode<K, N>, destNode: BSTNKeyOrNode<K, N>): N | undefined;
    /**
     * Time Complexity: O(1) - constant time, as it performs a fixed number of operations.
     * Space Complexity: O(1) - constant space, as it only uses a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as it performs a fixed number of operations.
     * Space Complexity: O(1) - constant space, as it only uses a constant amount of memory.
     *
     * The function calculates the balance factor of a node in a binary tree.
     * @param {N} node - The parameter "node" represents a node in a binary tree data structure.
     * @returns the balance factor of a given node. The balance factor is calculated by subtracting the
     * height of the left subtree from the height of the right subtree.
     */
    protected _balanceFactor(node: N): number;
    /**
     * Time Complexity: O(1) - constant time, as it performs a fixed number of operations.
     * Space Complexity: O(1) - constant space, as it only uses a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as it performs a fixed number of operations.
     * Space Complexity: O(1) - constant space, as it only uses a constant amount of memory.
     *
     * The function updates the height of a node in a binary tree based on the heights of its left and
     * right children.
     * @param {N} node - The parameter "node" represents a node in a binary tree data structure.
     */
    protected _updateHeight(node: N): void;
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The method traverses the path from the inserted node to the root.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     */
    /**
     * Time Complexity: O(log n) - logarithmic time, where "n" is the number of nodes in the tree. The method traverses the path from the inserted node to the root.
     * Space Complexity: O(1) - constant space, as it doesn't use additional data structures that scale with input size.
     *
     * The `_balancePath` function is used to update the heights of nodes and perform rotation operations
     * to restore balance in an AVL tree after inserting a node.
     * @param {N} node - The `node` parameter in the `_balancePath` function represents the node in the
     * AVL tree that needs to be balanced.
     */
    protected _balancePath(node: N): void;
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     *
     * The function `_balanceLL` performs a left-left rotation to balance a binary tree.
     * @param {N} A - A is a node in a binary tree.
     */
    protected _balanceLL(A: N): void;
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     *
     * The `_balanceLR` function performs a left-right rotation to balance a binary tree.
     * @param {N} A - A is a node in a binary tree.
     */
    protected _balanceLR(A: N): void;
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     *
     * The function `_balanceRR` performs a right-right rotation to balance a binary tree.
     * @param {N} A - A is a node in a binary tree.
     */
    protected _balanceRR(A: N): void;
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     */
    /**
     * Time Complexity: O(1) - constant time, as these methods perform a fixed number of operations.
     * Space Complexity: O(1) - constant space, as they only use a constant amount of memory.
     *
     * The function `_balanceRL` performs a right-left rotation to balance a binary tree.
     * @param {N} A - A is a node in a binary tree.
     */
    protected _balanceRL(A: N): void;
    protected _replaceNode(oldNode: N, newNode: N): N;
}
