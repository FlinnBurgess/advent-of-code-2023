/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import type { BinaryTreeDeleteResult, BinaryTreeNested, BinaryTreeNodeNested, BinaryTreeOptions, BinaryTreePrintOptions, BTNCallback, BTNEntry, BTNExemplar, BTNKeyOrNode, DFSOrderPattern, EntryCallback, NodeDisplayLayout } from '../../types';
import { FamilyPosition, IterationType } from '../../types';
import { IBinaryTree } from '../../interfaces';
import { IterableEntryBase } from "../base";
/**
 * Represents a node in a binary tree.
 * @template V - The type of data stored in the node.
 * @template N - The type of the family relationship in the binary tree.
 */
export declare class BinaryTreeNode<K = any, V = any, N extends BinaryTreeNode<K, V, N> = BinaryTreeNode<K, V, BinaryTreeNodeNested<K, V>>> {
    key: K;
    value?: V;
    parent?: N;
    constructor(key: K, value?: V);
    protected _left?: N | null;
    get left(): N | null | undefined;
    set left(v: N | null | undefined);
    protected _right?: N | null;
    get right(): N | null | undefined;
    set right(v: N | null | undefined);
    /**
     * Get the position of the node within its family.
     * @returns {FamilyPosition} - The family position of the node.
     */
    get familyPosition(): FamilyPosition;
}
/**
 * 1. Two Children Maximum: Each node has at most two children.
 * 2. Left and Right Children: Nodes have distinct left and right children.
 * 3. Depth and Height: Depth is the number of edges from the root to a node; height is the maximum depth in the tree.
 * 4. Subtrees: Each child of a node forms the root of a subtree.
 * 5. Leaf Nodes: Nodes without children are leaves.
 */
export declare class BinaryTree<K = any, V = any, N extends BinaryTreeNode<K, V, N> = BinaryTreeNode<K, V, BinaryTreeNodeNested<K, V>>, TREE extends BinaryTree<K, V, N, TREE> = BinaryTree<K, V, N, BinaryTreeNested<K, V, N>>> extends IterableEntryBase<K, V | undefined> implements IBinaryTree<K, V, N, TREE> {
    iterationType: IterationType;
    /**
     * The constructor function initializes a binary tree object with optional elements and options.
     * @param [elements] - An optional iterable of BTNExemplar objects. These objects represent the
     * elements to be added to the binary tree.
     * @param [options] - The `options` parameter is an optional object that can contain additional
     * configuration options for the binary tree. In this case, it is of type
     * `Partial<BinaryTreeOptions>`, which means that not all properties of `BinaryTreeOptions` are
     * required.
     */
    constructor(elements?: Iterable<BTNExemplar<K, V, N>>, options?: Partial<BinaryTreeOptions<K>>);
    protected _extractor: (key: K) => number;
    get extractor(): (key: K) => number;
    protected _root?: N | null;
    get root(): N | null | undefined;
    protected _size: number;
    get size(): number;
    /**
     * Creates a new instance of BinaryTreeNode with the given key and value.
     * @param {K} key - The key for the new node.
     * @param {V} value - The value for the new node.
     * @returns {N} - The newly created BinaryTreeNode.
     */
    createNode(key: K, value?: V): N;
    /**
     * The function creates a binary tree with the given options.
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the `BinaryTree` class. It is of type `Partial<BinaryTreeOptions>`, which means that
     * you can provide only a subset of the properties defined in the `BinaryTreeOptions` interface.
     * @returns a new instance of a binary tree.
     */
    createTree(options?: Partial<BinaryTreeOptions<K>>): TREE;
    /**
     * The function "isNode" checks if an exemplar is an instance of the BinaryTreeNode class.
     * @param exemplar - The `exemplar` parameter is a variable of type `BTNExemplar<K, V,N>`.
     * @returns a boolean value indicating whether the exemplar is an instance of the class N.
     */
    isNode(exemplar: BTNExemplar<K, V, N>): exemplar is N;
    /**
     * The function `exemplarToNode` converts an exemplar object into a node object.
     * @param exemplar - The `exemplar` parameter is of type `BTNExemplar<K, V, N>`.
     * @param {V} [value] - The `value` parameter is an optional value that can be passed to the
     * `exemplarToNode` function. It represents the value associated with the exemplar node. If no value
     * is provided, it will be `undefined`.
     * @returns a value of type N (node), or null, or undefined.
     */
    exemplarToNode(exemplar: BTNExemplar<K, V, N>, value?: V): N | null | undefined;
    /**
     * The function checks if a given value is an entry in a binary tree node.
     * @param kne - BTNExemplar<K, V,N> - A generic type representing a node in a binary tree. It has
     * two type parameters V and N, representing the value and node type respectively.
     * @returns a boolean value.
     */
    isEntry(kne: BTNExemplar<K, V, N>): kne is BTNEntry<K, V>;
    /**
     * Time Complexity O(log n) - O(n)
     * Space Complexity O(1)
     */
    /**
     * Time Complexity O(log n) - O(n)
     * Space Complexity O(1)
     *
     * The `add` function adds a new node to a binary tree, either by creating a new node or replacing an
     * existing node with the same key.
     * @param keyOrNodeOrEntry - The `keyOrNodeOrEntry` parameter can be one of the following:
     * @param {V} [value] - The value to be inserted into the binary tree.
     * @returns The function `add` returns either a node (`N`), `null`, or `undefined`.
     */
    add(keyOrNodeOrEntry: BTNExemplar<K, V, N>, value?: V): N | null | undefined;
    /**
     * Time Complexity: O(k log n) - O(k * n)
     * Space Complexity: O(1)
     * Comments: The time complexity for adding a node depends on the depth of the tree. In the best case (when the tree is empty), it's O(1). In the worst case (when the tree is a degenerate tree), it's O(n). The space complexity is constant.
     */
    /**
     * Time Complexity: O(k log n) - O(k * n)
     * Space Complexity: O(1)
     *
     * The `addMany` function takes in a collection of nodes and an optional collection of values, and
     * adds each node with its corresponding value to the data structure.
     * @param nodes - An iterable collection of BTNExemplar objects.
     * @param [values] - An optional iterable of values that will be assigned to each node being added.
     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.
     */
    addMany(nodes: Iterable<BTNExemplar<K, V, N>>, values?: Iterable<V | undefined>): (N | null | undefined)[];
    /**
     * Time Complexity: O(k * n)  "n" is the number of nodes in the tree, and "k" is the number of keys to be inserted.
     * Space Complexity: O(1)
     */
    refill(nodesOrKeysOrEntries: Iterable<BTNExemplar<K, V, N>>, values?: Iterable<V | undefined>): void;
    /**
     * Time Complexity: O(k * n)  "n" is the number of nodes in the tree, and "k" is the number of keys to be inserted.
     * Space Complexity: O(1)
     */
    delete<C extends BTNCallback<N, K>>(identifier: K, callback?: C): BinaryTreeDeleteResult<N>[];
    delete<C extends BTNCallback<N, N>>(identifier: N | null | undefined, callback?: C): BinaryTreeDeleteResult<N>[];
    delete<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback: C): BinaryTreeDeleteResult<N>[];
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function calculates the depth of a given node in a binary tree.
     * @param {K | N | null | undefined} distNode - The `distNode` parameter represents the node in
     * the binary tree whose depth we want to find. It can be of type `K`, `N`, `null`, or
     * `undefined`.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter is the starting node
     * from which we want to calculate the depth. It can be either a `K` (binary tree node key) or
     * `N` (binary tree node) or `null` or `undefined`. If no value is provided for `beginRoot
     * @returns the depth of the `distNode` relative to the `beginRoot`.
     */
    getDepth(distNode: BTNKeyOrNode<K, N>, beginRoot?: BTNKeyOrNode<K, N>): number;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `getHeight` calculates the maximum height of a binary tree using either recursive or
     * iterative traversal.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter represents the
     * starting node of the binary tree from which we want to calculate the height. It can be of type
     * `K`, `N`, `null`, or `undefined`. If not provided, it defaults to `this.root`.
     * @param iterationType - The `iterationType` parameter is used to determine whether to calculate the
     * height of the tree using a recursive approach or an iterative approach. It can have two possible
     * values:
     * @returns the height of the binary tree.
     */
    getHeight(beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): number;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     * Best Case - O(log n) (when using recursive iterationType), Worst Case - O(n) (when using iterative iterationType)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `getMinHeight` function calculates the minimum height of a binary tree using either a
     * recursive or iterative approach.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter represents the
     * starting node of the binary tree from which we want to calculate the minimum height. It can be of
     * type `K`, `N`, `null`, or `undefined`. If no value is provided, it defaults to `this.root`.
     * @param iterationType - The `iterationType` parameter is used to determine the method of iteration
     * to calculate the minimum height of a binary tree. It can have two possible values:
     * @returns The function `getMinHeight` returns the minimum height of a binary tree.
     */
    getMinHeight(beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): number;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     * Best Case - O(log n) (when using recursive iterationType), Worst Case - O(n) (when using iterative iterationType)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function checks if a binary tree is perfectly balanced by comparing the minimum height and the
     * height of the tree.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter is the starting point
     * for calculating the height and minimum height of a binary tree. It can be either a `K` (a key
     * value of a binary tree node), `N` (a node of a binary tree), `null`, or `undefined`. If
     * @returns a boolean value.
     */
    isPerfectlyBalanced(beginRoot?: BTNKeyOrNode<K, N>): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    getNodes<C extends BTNCallback<N, K>>(identifier: K, callback?: C, onlyOne?: boolean, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N[];
    getNodes<C extends BTNCallback<N, N>>(identifier: N | null | undefined, callback?: C, onlyOne?: boolean, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N[];
    getNodes<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback: C, onlyOne?: boolean, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N[];
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n).
     */
    has<C extends BTNCallback<N, K>>(identifier: K, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): boolean;
    has<C extends BTNCallback<N, N>>(identifier: N | null | undefined, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): boolean;
    has<C extends BTNCallback<N>>(identifier: ReturnType<C> | null | undefined, callback: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n).
     */
    getNode<C extends BTNCallback<N, K>>(identifier: K, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    getNode<C extends BTNCallback<N, N>>(identifier: N | null | undefined, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    getNode<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `getNodeByKey` searches for a node in a binary tree by its key, using either
     * recursive or iterative iteration.
     * @param {K} key - The `key` parameter is the key value that we are searching for in the tree.
     * It is used to find the node with the matching key value.
     * @param iterationType - The `iterationType` parameter is used to determine whether the search for
     * the node with the given key should be performed iteratively or recursively. It has two possible
     * values:
     * @returns The function `getNodeByKey` returns a node (`N`) if a node with the specified key is
     * found in the binary tree. If no node is found, it returns `undefined`.
     */
    getNodeByKey(key: K, iterationType?: IterationType): N | undefined;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * The function `ensureNode` returns the node corresponding to the given key if it is a valid node
     * key, otherwise it returns the key itself.
     * @param {K | N | null | undefined} key - The `key` parameter can be of type `K`, `N`,
     * `null`, or `undefined`. It represents a key used to identify a node in a binary tree.
     * @param iterationType - The `iterationType` parameter is an optional parameter that specifies the
     * type of iteration to be used when searching for a node by key. It has a default value of
     * `IterationType.ITERATIVE`.
     * @returns either the node corresponding to the given key if it is a valid node key, or the key
     * itself if it is not a valid node key.
     */
    ensureNode(key: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    get<C extends BTNCallback<N, K>>(identifier: K, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): V | undefined;
    get<C extends BTNCallback<N, N>>(identifier: N | null | undefined, callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): V | undefined;
    get<C extends BTNCallback<N>>(identifier: ReturnType<C>, callback: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): V | undefined;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Clear the binary tree, removing all nodes.
     */
    clear(): void;
    /**
     * Check if the binary tree is empty.
     * @returns {boolean} - True if the binary tree is empty, false otherwise.
     */
    isEmpty(): boolean;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     *
     * The function `getPathToRoot` returns an array of nodes from a given node to the root of a tree
     * structure, with the option to reverse the order of the nodes.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter represents the
     * starting node from which you want to find the path to the root. It can be of type `K`, `N`,
     * `null`, or `undefined`.
     * @param [isReverse=true] - The `isReverse` parameter is a boolean flag that determines whether the
     * resulting path should be reversed or not. If `isReverse` is set to `true`, the path will be
     * reversed before returning it. If `isReverse` is set to `false`, the path will be returned as is
     * @returns The function `getPathToRoot` returns an array of nodes (`N[]`).
     */
    getPathToRoot(beginRoot: BTNKeyOrNode<K, N>, isReverse?: boolean): N[];
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getLeftMost` returns the leftmost node in a binary tree, either recursively or
     * iteratively.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter is the starting point
     * for finding the leftmost node in a binary tree. It can be either a `K` (a key value), `N` (a
     * node), `null`, or `undefined`. If not provided, it defaults to `this.root`,
     * @param iterationType - The `iterationType` parameter is used to determine the type of iteration to
     * be performed when finding the leftmost node in a binary tree. It can have two possible values:
     * @returns The function `getLeftMost` returns the leftmost node (`N`) in the binary tree. If there
     * is no leftmost node, it returns `null` or `undefined` depending on the input.
     */
    getLeftMost(beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getRightMost` returns the rightmost node in a binary tree, either recursively or
     * iteratively.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter represents the
     * starting node from which we want to find the rightmost node. It can be of type `K`, `N`,
     * `null`, or `undefined`. If not provided, it defaults to `this.root`, which is a property of the
     * current object.
     * @param iterationType - The `iterationType` parameter is an optional parameter that specifies the
     * type of iteration to use when finding the rightmost node. It can have one of two values:
     * @returns The function `getRightMost` returns the rightmost node (`N`) in a binary tree. If there
     * is no rightmost node, it returns `null` or `undefined`, depending on the input.
     */
    getRightMost(beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType): N | null | undefined;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `isSubtreeBST` checks if a given binary tree is a valid binary search tree.
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter represents the root
     * node of the binary search tree (BST) that you want to check if it is a subtree of another BST.
     * @param iterationType - The `iterationType` parameter is an optional parameter that specifies the
     * type of iteration to use when checking if a subtree is a binary search tree (BST). It can have two
     * possible values:
     * @returns a boolean value.
     */
    isSubtreeBST(beginRoot: BTNKeyOrNode<K, N>, iterationType?: IterationType): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a binary tree is a binary search tree.
     * @param iterationType - The parameter "iterationType" is used to specify the type of iteration to
     * be used when checking if the binary tree is a binary search tree (BST). It is an optional
     * parameter with a default value of "this.iterationType". The value of "this.iterationType" is
     * expected to be
     * @returns a boolean value.
     */
    isBST(iterationType?: IterationType): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    subTreeTraverse<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[];
    subTreeTraverse<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: undefined): ReturnType<C>[];
    subTreeTraverse<C extends BTNCallback<N | null | undefined>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[];
    /**
     * Time complexity: O(n)
     * Space complexity: O(log n)
     */
    /**
     * The function checks if a given node is a real node by verifying if it is an instance of
     * BinaryTreeNode and its key is not NaN.
     * @param {any} node - The parameter `node` is of type `any`, which means it can be any data type.
     * @returns a boolean value.
     */
    isRealNode(node: BTNExemplar<K, V, N>): node is N;
    /**
     * The function checks if a given node is a BinaryTreeNode instance and has a key value of NaN.
     * @param {any} node - The parameter `node` is of type `any`, which means it can be any data type.
     * @returns a boolean value.
     */
    isNIL(node: BTNExemplar<K, V, N>): boolean;
    /**
     * The function checks if a given node is a real node or null.
     * @param {any} node - The parameter `node` is of type `any`, which means it can be any data type.
     * @returns a boolean value.
     */
    isNodeOrNull(node: BTNExemplar<K, V, N>): node is N | null;
    /**
     * The function "isNotNodeInstance" checks if a potential key is a K.
     * @param {any} potentialKey - The potentialKey parameter is of type any, which means it can be any
     * data type.
     * @returns a boolean value indicating whether the potentialKey is of type number or not.
     */
    isNotNodeInstance(potentialKey: BTNKeyOrNode<K, N>): potentialKey is K;
    dfs<C extends BTNCallback<N>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[];
    dfs<C extends BTNCallback<N>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: undefined): ReturnType<C>[];
    dfs<C extends BTNCallback<N | null | undefined>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[];
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    bfs<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[];
    bfs<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: undefined): ReturnType<C>[];
    bfs<C extends BTNCallback<N | null | undefined>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[];
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    listLevels<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[][];
    listLevels<C extends BTNCallback<N>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: undefined): ReturnType<C>[][];
    listLevels<C extends BTNCallback<N | null | undefined>>(callback?: C, beginRoot?: BTNKeyOrNode<K, N>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[][];
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function returns the predecessor of a given node in a tree.
     * @param {N} node - The parameter `node` is of type `RedBlackTreeNode`, which represents a node in a
     * tree.
     * @returns the predecessor of the given 'node'.
     */
    getPredecessor(node: N): N;
    /**
     * The function `getSuccessor` returns the next node in a binary tree given a current node.
     * @param {K | N | null} [x] - The parameter `x` can be of type `K`, `N`, or `null`.
     * @returns the successor of the given node or key. The successor is the node that comes immediately
     * after the given node in the inorder traversal of the binary tree.
     */
    getSuccessor(x?: K | N | null): N | null | undefined;
    /**
     * Time complexity: O(n)
     * Space complexity: O(1)
     * The `morris` function performs a depth-first traversal on a binary tree using the Morris traversal
     * algorithm.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node in
     * the tree. It takes a single parameter of type `N` (the type of the nodes in the tree) and returns
     * a value of any type.
     * @param {DFSOrderPattern} [pattern=in] - The `pattern` parameter in the `morris` function
     * determines the order in which the nodes of a binary tree are traversed. It can have one of the
     * following values:
     * @param {K | N | null | undefined} beginRoot - The `beginRoot` parameter is the starting node
     * for the traversal. It can be specified as a key, a node object, or `null`/`undefined` to indicate
     * the root of the tree. If no value is provided, the default value is the root of the tree.
     * @returns The function `morris` returns an array of values that are the result of invoking the
     * `callback` function on each node in the binary tree. The type of the array elements is determined
     * by the return type of the `callback` function.
     */
    morris<C extends BTNCallback<N>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: BTNKeyOrNode<K, N>): ReturnType<C>[];
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `clone` function creates a new tree object and copies all the nodes from the original tree to
     * the new tree.
     * @returns The `clone()` method is returning a cloned instance of the `TREE` object.
     */
    clone(): TREE;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new tree by iterating over the elements of the current tree and
     * adding only the elements that satisfy the given predicate function.
     * @param predicate - The `predicate` parameter is a function that takes three arguments: `value`,
     * `key`, and `index`. It should return a boolean value indicating whether the pair should be
     * included in the filtered tree or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,
     * it will be passed as the first argument to the `predicate` function. If `thisArg` is
     * @returns The `filter` method is returning a new tree object that contains the key-value pairs that
     * pass the given predicate function.
     */
    filter(predicate: EntryCallback<K, V | undefined, boolean>, thisArg?: any): TREE;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new tree by applying a callback function to each key-value pair in
     * the original tree.
     * @param callback - The callback parameter is a function that will be called for each key-value pair
     * in the tree. It takes four arguments: the value of the current pair, the key of the current pair,
     * the index of the current pair, and a reference to the tree itself. The callback function should
     * return a new
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If you pass a value for `thisArg`, it
     * will be used as the `this` value when the callback function is called. If you don't pass a value
     * @returns The `map` method is returning a new tree object.
     */
    map(callback: EntryCallback<K, V | undefined, V>, thisArg?: any): TREE;
    /**
     * The `print` function is used to display a binary tree structure in a visually appealing way.
     * @param {K | N | null | undefined} [beginRoot=this.root] - The `root` parameter is of type `K | N | null |
     * undefined`. It represents the root node of a binary tree. The root node can have one of the
     * following types:
     * @param {BinaryTreePrintOptions} [options={ isShowUndefined: false, isShowNull: false, isShowRedBlackNIL: false}] - Options object that controls printing behavior. You can specify whether to display undefined, null, or sentinel nodes.
     */
    print(beginRoot?: BTNKeyOrNode<K, N>, options?: BinaryTreePrintOptions): void;
    protected _getIterator(node?: N | null | undefined): IterableIterator<[K, V | undefined]>;
    protected _displayAux(node: N | null | undefined, options: BinaryTreePrintOptions): NodeDisplayLayout;
    protected _defaultOneParamCallback: (node: N) => K;
    /**
     * Swap the data of two nodes in the binary tree.
     * @param {N} srcNode - The source node to swap.
     * @param {N} destNode - The destination node to swap.
     * @returns {N} - The destination node after the swap.
     */
    protected _swapProperties(srcNode: BTNKeyOrNode<K, N>, destNode: BTNKeyOrNode<K, N>): N | undefined;
    /**
     * The function replaces an old node with a new node in a binary tree.
     * @param {N} oldNode - The oldNode parameter represents the node that needs to be replaced in the
     * tree.
     * @param {N} newNode - The `newNode` parameter is the node that will replace the `oldNode` in the
     * tree.
     * @returns The method is returning the newNode.
     */
    protected _replaceNode(oldNode: N, newNode: N): N;
    /**
     * The function `_addTo` adds a new node to a binary tree if there is an available position.
     * @param {N | null | undefined} newNode - The `newNode` parameter represents the node that you want to add to
     * the binary tree. It can be either a node object or `null`.
     * @param {N} parent - The `parent` parameter represents the parent node to which the new node will
     * be added as a child.
     * @returns either the left or right child node of the parent node, depending on which child is
     * available for adding the new node. If a new node is added, the function also updates the size of
     * the binary tree. If neither the left nor right child is available, the function returns undefined.
     * If the parent node is null, the function also returns undefined.
     */
    protected _addTo(newNode: N | null | undefined, parent: BTNKeyOrNode<K, N>): N | null | undefined;
    /**
     * The function sets the root property of an object to a given value, and if the value is not null,
     * it also sets the parent property of the value to undefined.
     * @param {N | null | undefined} v - The parameter `v` is of type `N | null | undefined`, which means it can either be of
     * type `N` or `null`.
     */
    protected _setRoot(v: N | null | undefined): void;
}
