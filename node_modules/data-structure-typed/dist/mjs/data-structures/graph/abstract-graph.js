import { uuidV4 } from '../../utils';
import { IterableEntryBase } from "../base";
import { Heap } from '../heap';
import { Queue } from '../queue';
export class AbstractVertex {
    key;
    value;
    /**
     * The function is a protected constructor that takes an key and an optional value as parameters.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is
     * used to uniquely identify the vertex object.
     * @param {V} [value] - The parameter "value" is an optional parameter of type V. It is used to assign a value to the
     * vertex. If no value is provided, it will be set to undefined.
     */
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
export class AbstractEdge {
    value;
    weight;
    /**
     * The above function is a protected constructor that initializes the weight, value, and hash code properties of an
     * object.
     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the object. If
     * a value is provided, it will be assigned to the `_weight` property. If no value is provided, the default value of 1
     * will be assigned.
     * @param {VO} [value] - The `value` parameter is of type `VO`, which means it can be any type. It is an optional parameter,
     * meaning it can be omitted when creating an instance of the class.
     */
    constructor(weight, value) {
        this.weight = weight !== undefined ? weight : 1;
        this.value = value;
        this._hashCode = uuidV4();
    }
    _hashCode;
    get hashCode() {
        return this._hashCode;
    }
}
export class AbstractGraph extends IterableEntryBase {
    constructor() {
        super();
    }
    _vertexMap = new Map();
    get vertexMap() {
        return this._vertexMap;
    }
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function "getVertex" returns the vertex with the specified ID or undefined if it doesn't exist.
     * @param {VertexKey} vertexKey - The `vertexKey` parameter is the identifier of the vertex that you want to retrieve from
     * the `_vertexMap` map.
     * @returns The method `getVertex` returns the vertex with the specified `vertexKey` if it exists in the `_vertexMap`
     * map. If the vertex does not exist, it returns `undefined`.
     */
    getVertex(vertexKey) {
        return this._vertexMap.get(vertexKey) || undefined;
    }
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function checks if a vertex exists in a graph.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns a boolean value.
     */
    hasVertex(vertexOrKey) {
        return this._vertexMap.has(this._getVertexKey(vertexOrKey));
    }
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    addVertex(keyOrVertex, value) {
        if (keyOrVertex instanceof AbstractVertex) {
            return this._addVertexOnly(keyOrVertex);
        }
        else {
            const newVertex = this.createVertex(keyOrVertex, value);
            return this._addVertexOnly(newVertex);
        }
    }
    isVertexKey(potentialKey) {
        const potentialKeyType = typeof potentialKey;
        return potentialKeyType === "string" || potentialKeyType === "number";
    }
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The `deleteVertex` function removes a vertex from a graph by its ID or by the vertex object itself.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method is returning a boolean value.
     */
    deleteVertex(vertexOrKey) {
        const vertexKey = this._getVertexKey(vertexOrKey);
        return this._vertexMap.delete(vertexKey);
    }
    /**
     * Time Complexity: O(K), where K is the number of vertexMap to be removed.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(K), where K is the number of vertexMap to be removed.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function removes all vertexMap from a graph and returns a boolean indicating if any vertexMap were removed.
     * @param {VO[] | VertexKey[]} vertexMap - The `vertexMap` parameter can be either an array of vertexMap (`VO[]`) or an array
     * of vertex IDs (`VertexKey[]`).
     * @returns a boolean value. It returns true if at least one vertex was successfully removed, and false if no vertexMap
     * were removed.
     */
    removeManyVertices(vertexMap) {
        const removed = [];
        for (const v of vertexMap) {
            removed.push(this.deleteVertex(v));
        }
        return removed.length > 0;
    }
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     */
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     *
     * The function checks if there is an edge between two vertexMap and returns a boolean value indicating the result.
     * @param {VertexKey | VO} v1 - The parameter v1 can be either a VertexKey or a VO. A VertexKey represents the unique
     * identifier of a vertex in a graph, while VO represents the type of the vertex object itself.
     * @param {VertexKey | VO} v2 - The parameter `v2` represents the second vertex in the edge. It can be either a
     * `VertexKey` or a `VO` type, which represents the type of the vertex.
     * @returns A boolean value is being returned.
     */
    hasEdge(v1, v2) {
        const edge = this.getEdge(v1, v2);
        return !!edge;
    }
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     */
    addEdge(srcOrEdge, dest, weight, value) {
        if (srcOrEdge instanceof AbstractEdge) {
            return this._addEdgeOnly(srcOrEdge);
        }
        else {
            if (dest instanceof AbstractVertex || typeof dest === 'string' || typeof dest === 'number') {
                if (!(this.hasVertex(srcOrEdge) && this.hasVertex(dest)))
                    return false;
                if (srcOrEdge instanceof AbstractVertex)
                    srcOrEdge = srcOrEdge.key;
                if (dest instanceof AbstractVertex)
                    dest = dest.key;
                const newEdge = this.createEdge(srcOrEdge, dest, weight, value);
                return this._addEdgeOnly(newEdge);
            }
            else {
                throw new Error('dest must be a Vertex or vertex key while srcOrEdge is an Edge');
            }
        }
    }
    /**
     * Time Complexity: O(1) - Constant time for Map and Edge operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map and Edge operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function sets the weight of an edge between two vertexMap in a graph.
     * @param {VertexKey | VO} srcOrKey - The `srcOrKey` parameter can be either a `VertexKey` or a `VO` object. It represents
     * the source vertex of the edge.
     * @param {VertexKey | VO} destOrKey - The `destOrKey` parameter represents the destination vertex of the edge. It can be
     * either a `VertexKey` or a vertex object `VO`.
     * @param {number} weight - The weight parameter represents the weight of the edge between the source vertex (srcOrKey)
     * and the destination vertex (destOrKey).
     * @returns a boolean value. If the edge exists between the source and destination vertexMap, the function will update
     * the weight of the edge and return true. If the edge does not exist, the function will return false.
     */
    setEdgeWeight(srcOrKey, destOrKey, weight) {
        const edge = this.getEdge(srcOrKey, destOrKey);
        if (edge) {
            edge.weight = weight;
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Time Complexity: O(P), where P is the number of paths found (in the worst case, exploring all paths).
     * Space Complexity: O(P) - Linear space, where P is the number of paths found.
     */
    /**
     * Time Complexity: O(P), where P is the number of paths found (in the worst case, exploring all paths).
     * Space Complexity: O(P) - Linear space, where P is the number of paths found.
     *
     * The function `getAllPathsBetween` finds all paths between two vertexMap in a graph using depth-first search.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents either a vertex object (`VO`) or a vertex ID (`VertexKey`).
     * It is the starting vertex for finding paths.
     * @param {VO | VertexKey} v2 - The parameter `v2` represents either a vertex object (`VO`) or a vertex ID (`VertexKey`).
     * @param limit - The count of limitation of result array.
     * @returns The function `getAllPathsBetween` returns an array of arrays of vertexMap (`VO[][]`).
     */
    getAllPathsBetween(v1, v2, limit = 1000) {
        const paths = [];
        const vertex1 = this._getVertex(v1);
        const vertex2 = this._getVertex(v2);
        if (!(vertex1 && vertex2)) {
            return [];
        }
        const stack = [];
        stack.push({ vertex: vertex1, path: [vertex1] });
        while (stack.length > 0) {
            const { vertex, path } = stack.pop();
            if (vertex === vertex2) {
                paths.push(path);
                if (paths.length >= limit)
                    return paths;
            }
            const neighbors = this.getNeighbors(vertex);
            for (const neighbor of neighbors) {
                if (!path.includes(neighbor)) {
                    const newPath = [...path, neighbor];
                    stack.push({ vertex: neighbor, path: newPath });
                }
            }
        }
        return paths;
    }
    /**
     * Time Complexity: O(L), where L is the length of the path.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(L), where L is the length of the path.
     * Space Complexity: O(1) - Constant space.
     *
     * The function calculates the sum of weights along a given path.
     * @param {VO[]} path - An array of vertexMap (VO) representing a path in a graph.
     * @returns The function `getPathSumWeight` returns the sum of the weights of the edgeMap in the given path.
     */
    getPathSumWeight(path) {
        let sum = 0;
        for (let i = 0; i < path.length; i++) {
            sum += this.getEdge(path[i], path[i + 1])?.weight || 0;
        }
        return sum;
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     *
     * The function `getMinCostBetween` calculates the minimum cost between two vertexMap in a graph, either based on edge
     * weights or using a breadth-first search algorithm.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents the starting vertex or its ID.
     * @param {VO | VertexKey} v2 - The parameter `v2` represents the destination vertex or its ID. It is the vertex to which
     * you want to find the minimum cost or weight from the source vertex `v1`.
     * @param {boolean} [isWeight] - isWeight is an optional parameter that indicates whether the graph edgeMap have weights.
     * If isWeight is set to true, the function will calculate the minimum cost between v1 and v2 based on the weights of
     * the edgeMap. If isWeight is set to false or not provided, the function will calculate the
     * @returns The function `getMinCostBetween` returns a number representing the minimum cost between two vertexMap (`v1`
     * and `v2`). If the `isWeight` parameter is `true`, it calculates the minimum weight among all paths between the
     * vertexMap. If `isWeight` is `false` or not provided, it uses a breadth-first search (BFS) algorithm to calculate the
     * minimum number of
     */
    getMinCostBetween(v1, v2, isWeight) {
        if (isWeight === undefined)
            isWeight = false;
        if (isWeight) {
            const allPaths = this.getAllPathsBetween(v1, v2);
            let min = Infinity;
            for (const path of allPaths) {
                min = Math.min(this.getPathSumWeight(path), min);
            }
            return min;
        }
        else {
            // BFS
            const vertex2 = this._getVertex(v2);
            const vertex1 = this._getVertex(v1);
            if (!(vertex1 && vertex2)) {
                return undefined;
            }
            const visited = new Map();
            const queue = new Queue([vertex1]);
            visited.set(vertex1, true);
            let cost = 0;
            while (queue.size > 0) {
                for (let i = 0; i < queue.size; i++) {
                    const cur = queue.shift();
                    if (cur === vertex2) {
                        return cost;
                    }
                    // TODO consider optimizing to AbstractGraph
                    if (cur !== undefined) {
                        const neighbors = this.getNeighbors(cur);
                        for (const neighbor of neighbors) {
                            if (!visited.has(neighbor)) {
                                visited.set(neighbor, true);
                                queue.push(neighbor);
                            }
                        }
                    }
                }
                cost++;
            }
            return undefined;
        }
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     *
     * The function `getMinPathBetween` returns the minimum path between two vertexMap in a graph, either based on weight or
     * using a breadth-first search algorithm.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents the starting vertex of the path. It can be either a vertex
     * object (`VO`) or a vertex ID (`VertexKey`).
     * @param {VO | VertexKey} v2 - VO | VertexKey - The second vertex or vertex ID between which we want to find the minimum
     * path.
     * @param {boolean} [isWeight] - A boolean flag indicating whether to consider the weight of edgeMap in finding the
     * minimum path. If set to true, the function will use Dijkstra's algorithm to find the minimum weighted path. If set
     * to false, the function will use breadth-first search (BFS) to find the minimum path.
     * @param isDFS - If set to true, it enforces the use of getAllPathsBetween to first obtain all possible paths,
     * followed by iterative computation of the shortest path. This approach may result in exponential time complexity,
     * so the default method is to use the Dijkstra algorithm to obtain the shortest weighted path.
     * @returns The function `getMinPathBetween` returns an array of vertexMap (`VO[]`) representing the minimum path between
     * two vertexMap (`v1` and `v2`). If there is no path between the vertexMap, it returns `undefined`.
     */
    getMinPathBetween(v1, v2, isWeight, isDFS = false) {
        if (isWeight === undefined)
            isWeight = false;
        if (isWeight) {
            if (isDFS) {
                const allPaths = this.getAllPathsBetween(v1, v2, 10000);
                let min = Infinity;
                let minIndex = -1;
                let index = 0;
                for (const path of allPaths) {
                    const pathSumWeight = this.getPathSumWeight(path);
                    if (pathSumWeight < min) {
                        min = pathSumWeight;
                        minIndex = index;
                    }
                    index++;
                }
                return allPaths[minIndex] || undefined;
            }
            else {
                return this.dijkstra(v1, v2, true, true)?.minPath ?? [];
            }
        }
        else {
            // DFS
            let minPath = [];
            const vertex1 = this._getVertex(v1);
            const vertex2 = this._getVertex(v2);
            if (!(vertex1 && vertex2))
                return [];
            const dfs = (cur, dest, visiting, path) => {
                visiting.add(cur);
                if (cur === dest) {
                    minPath = [vertex1, ...path];
                    return;
                }
                const neighbors = this.getNeighbors(cur);
                for (const neighbor of neighbors) {
                    if (!visiting.has(neighbor)) {
                        path.push(neighbor);
                        dfs(neighbor, dest, visiting, path);
                        path.pop();
                    }
                }
                visiting.delete(cur);
            };
            dfs(vertex1, vertex2, new Set(), []);
            return minPath;
        }
    }
    /**
     *  Dijkstra algorithm time: O(VE) space: O(VO + EO)
     * /
  
     /**
     * Time Complexity: O(V^2 + E) - Quadratic time in the worst case (no heap optimization).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     */
    /**
     * Time Complexity: O(V^2 + E) - Quadratic time in the worst case (no heap optimization).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     *
     * The function `dijkstraWithoutHeap` implements Dijkstra's algorithm to find the shortest path between two vertexMap in
     * a graph without using a heap data structure.
     * @param {VO | VertexKey} src - The source vertex from which to start the Dijkstra's algorithm. It can be either a
     * vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} [dest] - The `dest` parameter in the `dijkstraWithoutHeap` function is an optional
     * parameter that specifies the destination vertex for the Dijkstra algorithm. It can be either a vertex object or its
     * identifier. If no destination is provided, the value is set to `undefined`.
     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum
     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If
     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance
     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate
     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the
     * shortest paths from the source vertex to all other vertexMap in the graph. If `genPaths
     * @returns The function `dijkstraWithoutHeap` returns an object of type `DijkstraResult<VO>`.
     */
    dijkstraWithoutHeap(src, dest = undefined, getMinDist = false, genPaths = false) {
        let minDist = Infinity;
        let minDest = undefined;
        let minPath = [];
        const paths = [];
        const vertexMap = this._vertexMap;
        const distMap = new Map();
        const seen = new Set();
        const preMap = new Map(); // predecessor
        const srcVertex = this._getVertex(src);
        const destVertex = dest ? this._getVertex(dest) : undefined;
        if (!srcVertex) {
            return undefined;
        }
        for (const vertex of vertexMap) {
            const vertexOrKey = vertex[1];
            if (vertexOrKey instanceof AbstractVertex)
                distMap.set(vertexOrKey, Infinity);
        }
        distMap.set(srcVertex, 0);
        preMap.set(srcVertex, undefined);
        const getMinOfNoSeen = () => {
            let min = Infinity;
            let minV = undefined;
            for (const [key, value] of distMap) {
                if (!seen.has(key)) {
                    if (value < min) {
                        min = value;
                        minV = key;
                    }
                }
            }
            return minV;
        };
        const getPaths = (minV) => {
            for (const vertex of vertexMap) {
                const vertexOrKey = vertex[1];
                if (vertexOrKey instanceof AbstractVertex) {
                    const path = [vertexOrKey];
                    let parent = preMap.get(vertexOrKey);
                    while (parent) {
                        path.push(parent);
                        parent = preMap.get(parent);
                    }
                    const reversed = path.reverse();
                    if (vertex[1] === minV)
                        minPath = reversed;
                    paths.push(reversed);
                }
            }
        };
        for (let i = 1; i < vertexMap.size; i++) {
            const cur = getMinOfNoSeen();
            if (cur) {
                seen.add(cur);
                if (destVertex && destVertex === cur) {
                    if (getMinDist) {
                        minDist = distMap.get(destVertex) || Infinity;
                    }
                    if (genPaths) {
                        getPaths(destVertex);
                    }
                    return { distMap, preMap, seen, paths, minDist, minPath };
                }
                const neighbors = this.getNeighbors(cur);
                for (const neighbor of neighbors) {
                    if (!seen.has(neighbor)) {
                        const edge = this.getEdge(cur, neighbor);
                        if (edge) {
                            const curFromMap = distMap.get(cur);
                            const neighborFromMap = distMap.get(neighbor);
                            // TODO after no-non-undefined-assertion not ensure the logic
                            if (curFromMap !== undefined && neighborFromMap !== undefined) {
                                if (edge.weight + curFromMap < neighborFromMap) {
                                    distMap.set(neighbor, edge.weight + curFromMap);
                                    preMap.set(neighbor, cur);
                                }
                            }
                        }
                    }
                }
            }
        }
        getMinDist &&
            distMap.forEach((d, v) => {
                if (v !== srcVertex) {
                    if (d < minDist) {
                        minDist = d;
                        if (genPaths)
                            minDest = v;
                    }
                }
            });
        genPaths && getPaths(minDest);
        return { distMap, preMap, seen, paths, minDist, minPath };
    }
    /**
     *  Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     *
     * Dijkstra's algorithm only solves the single-source shortest path problem, while the Bellman-Ford algorithm and Floyd-Warshall algorithm can address shortest paths between all pairs of nodes.
     * Dijkstra's algorithm is suitable for graphs with non-negative edge weights, whereas the Bellman-Ford algorithm and Floyd-Warshall algorithm can handle negative-weight edgeMap.
     * The time complexity of Dijkstra's algorithm and the Bellman-Ford algorithm depends on the size of the graph, while the time complexity of the Floyd-Warshall algorithm is O(VO^3), where VO is the number of nodes. For dense graphs, Floyd-Warshall might become slower.
     *
     * /
  
     /**
     * Time Complexity: O((V + E) * log(V)) - Depends on the implementation (using a binary heap).
     * Space Complexity: O(V + E) - Depends on the implementation (using a binary heap).
     */
    /**
     * Time Complexity: O((V + E) * log(V)) - Depends on the implementation (using a binary heap).
     * Space Complexity: O(V + E) - Depends on the implementation (using a binary heap).
     *
     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.
     * The `dijkstra` function implements Dijkstra's algorithm to find the shortest path between a source vertex and an
     * optional destination vertex, and optionally returns the minimum distance, the paths, and other information.
     * @param {VO | VertexKey} src - The `src` parameter represents the source vertex from which the Dijkstra algorithm will
     * start. It can be either a vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} [dest] - The `dest` parameter is the destination vertex or vertex ID. It specifies the
     * vertex to which the shortest path is calculated from the source vertex. If no destination is provided, the algorithm
     * will calculate the shortest paths to all other vertexMap from the source vertex.
     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum
     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If
     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance
     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate
     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the
     * shortest paths from the source vertex to all other vertexMap in the graph. If `genPaths
     * @returns The function `dijkstra` returns an object of type `DijkstraResult<VO>`.
     */
    dijkstra(src, dest = undefined, getMinDist = false, genPaths = false) {
        let minDist = Infinity;
        let minDest = undefined;
        let minPath = [];
        const paths = [];
        const vertexMap = this._vertexMap;
        const distMap = new Map();
        const seen = new Set();
        const preMap = new Map(); // predecessor
        const srcVertex = this._getVertex(src);
        const destVertex = dest ? this._getVertex(dest) : undefined;
        if (!srcVertex)
            return undefined;
        for (const vertex of vertexMap) {
            const vertexOrKey = vertex[1];
            if (vertexOrKey instanceof AbstractVertex)
                distMap.set(vertexOrKey, Infinity);
        }
        const heap = new Heap([], { comparator: (a, b) => a.key - b.key });
        heap.add({ key: 0, value: srcVertex });
        distMap.set(srcVertex, 0);
        preMap.set(srcVertex, undefined);
        /**
         * The function `getPaths` retrieves all paths from vertexMap to a specified minimum vertex.
         * @param {VO | undefined} minV - The parameter `minV` is of type `VO | undefined`. It represents the minimum vertex value or
         * undefined.
         */
        const getPaths = (minV) => {
            for (const vertex of vertexMap) {
                const vertexOrKey = vertex[1];
                if (vertexOrKey instanceof AbstractVertex) {
                    const path = [vertexOrKey];
                    let parent = preMap.get(vertexOrKey);
                    while (parent) {
                        path.push(parent);
                        parent = preMap.get(parent);
                    }
                    const reversed = path.reverse();
                    if (vertex[1] === minV)
                        minPath = reversed;
                    paths.push(reversed);
                }
            }
        };
        while (heap.size > 0) {
            const curHeapNode = heap.poll();
            const dist = curHeapNode?.key;
            const cur = curHeapNode?.value;
            if (dist !== undefined) {
                if (cur) {
                    seen.add(cur);
                    if (destVertex && destVertex === cur) {
                        if (getMinDist) {
                            minDist = distMap.get(destVertex) || Infinity;
                        }
                        if (genPaths) {
                            getPaths(destVertex);
                        }
                        return { distMap, preMap, seen, paths, minDist, minPath };
                    }
                    const neighbors = this.getNeighbors(cur);
                    for (const neighbor of neighbors) {
                        if (!seen.has(neighbor)) {
                            const weight = this.getEdge(cur, neighbor)?.weight;
                            if (typeof weight === 'number') {
                                const distSrcToNeighbor = distMap.get(neighbor);
                                if (distSrcToNeighbor) {
                                    if (dist + weight < distSrcToNeighbor) {
                                        heap.add({ key: dist + weight, value: neighbor });
                                        preMap.set(neighbor, cur);
                                        distMap.set(neighbor, dist + weight);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (getMinDist) {
            distMap.forEach((d, v) => {
                if (v !== srcVertex) {
                    if (d < minDist) {
                        minDist = d;
                        if (genPaths)
                            minDest = v;
                    }
                }
            });
        }
        if (genPaths) {
            getPaths(minDest);
        }
        return { distMap, preMap, seen, paths, minDist, minPath };
    }
    /**
     * Time Complexity: O(V * E) - Quadratic time in the worst case (Bellman-Ford algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Bellman-Ford algorithm).
     * one to rest pairs
     * /
  
     /**
     * Time Complexity: O(V * E) - Quadratic time in the worst case (Bellman-Ford algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Bellman-Ford algorithm).
     *
     * one to rest pairs
     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edgeMap for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edgeMap, the Bellman-Ford algorithm is more flexible in some scenarios.
     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to
     * all other vertexMap in a graph, and optionally detects negative cycles and generates the minimum path.
     * @param {VO | VertexKey} src - The `src` parameter is the source vertex from which the Bellman-Ford algorithm will
     * start calculating the shortest paths. It can be either a vertex object or a vertex ID.
     * @param {boolean} [scanNegativeCycle] - A boolean flag indicating whether to scan for negative cycles in the graph.
     * @param {boolean} [getMin] - The `getMin` parameter is a boolean flag that determines whether the algorithm should
     * calculate the minimum distance from the source vertex to all other vertexMap in the graph. If `getMin` is set to
     * `true`, the algorithm will find the minimum distance and update the `min` variable with the minimum
     * @param {boolean} [genPath] - A boolean flag indicating whether to generate paths for all vertexMap from the source
     * vertex.
     * @returns The function `bellmanFord` returns an object with the following properties:
     */
    bellmanFord(src, scanNegativeCycle, getMin, genPath) {
        if (getMin === undefined)
            getMin = false;
        if (genPath === undefined)
            genPath = false;
        const srcVertex = this._getVertex(src);
        const paths = [];
        const distMap = new Map();
        const preMap = new Map(); // predecessor
        let min = Infinity;
        let minPath = [];
        // TODO
        let hasNegativeCycle;
        if (scanNegativeCycle)
            hasNegativeCycle = false;
        if (!srcVertex)
            return { hasNegativeCycle, distMap, preMap, paths, min, minPath };
        const vertexMap = this._vertexMap;
        const numOfVertices = vertexMap.size;
        const edgeMap = this.edgeSet();
        const numOfEdges = edgeMap.length;
        this._vertexMap.forEach(vertex => {
            distMap.set(vertex, Infinity);
        });
        distMap.set(srcVertex, 0);
        for (let i = 1; i < numOfVertices; ++i) {
            for (let j = 0; j < numOfEdges; ++j) {
                const ends = this.getEndsOfEdge(edgeMap[j]);
                if (ends) {
                    const [s, d] = ends;
                    const weight = edgeMap[j].weight;
                    const sWeight = distMap.get(s);
                    const dWeight = distMap.get(d);
                    if (sWeight !== undefined && dWeight !== undefined) {
                        if (distMap.get(s) !== Infinity && sWeight + weight < dWeight) {
                            distMap.set(d, sWeight + weight);
                            genPath && preMap.set(d, s);
                        }
                    }
                }
            }
        }
        let minDest = undefined;
        if (getMin) {
            distMap.forEach((d, v) => {
                if (v !== srcVertex) {
                    if (d < min) {
                        min = d;
                        if (genPath)
                            minDest = v;
                    }
                }
            });
        }
        if (genPath) {
            for (const vertex of vertexMap) {
                const vertexOrKey = vertex[1];
                if (vertexOrKey instanceof AbstractVertex) {
                    const path = [vertexOrKey];
                    let parent = preMap.get(vertexOrKey);
                    while (parent !== undefined) {
                        path.push(parent);
                        parent = preMap.get(parent);
                    }
                    const reversed = path.reverse();
                    if (vertex[1] === minDest)
                        minPath = reversed;
                    paths.push(reversed);
                }
            }
        }
        for (let j = 0; j < numOfEdges; ++j) {
            const ends = this.getEndsOfEdge(edgeMap[j]);
            if (ends) {
                const [s] = ends;
                const weight = edgeMap[j].weight;
                const sWeight = distMap.get(s);
                if (sWeight) {
                    if (sWeight !== Infinity && sWeight + weight < sWeight)
                        hasNegativeCycle = true;
                }
            }
        }
        return { hasNegativeCycle, distMap, preMap, paths, min, minPath };
    }
    /**
     * Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     * /
  
     /**
     * Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.
     */
    /**
     * BellmanFord time:O(VE) space:O(VO)
     * one to rest pairs
     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edgeMap for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edgeMap, the Bellman-Ford algorithm is more flexible in some scenarios.
     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to
     */
    /**
     * Time Complexity: O(V^3) - Cubic time (Floyd-Warshall algorithm).
     * Space Complexity: O(V^2) - Quadratic space (Floyd-Warshall algorithm).
     * Not support graph with negative weight cycle
     * all pairs
     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edgeMap, and it can simultaneously compute shortest paths between any two nodes.
     * /
  
     /**
     * Time Complexity: O(V^3) - Cubic time (Floyd-Warshall algorithm).
     * Space Complexity: O(V^2) - Quadratic space (Floyd-Warshall algorithm).
     *
     * Not support graph with negative weight cycle
     * all pairs
     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edgeMap, and it can simultaneously compute shortest paths between any two nodes.
     * The function implements the Floyd-Warshall algorithm to find the shortest path between all pairs of vertexMap in a
     * graph.
     * @returns The function `floydWarshall()` returns an object with two properties: `costs` and `predecessor`. The `costs`
     * property is a 2D array of numbers representing the shortest path costs between vertexMap in a graph. The
     * `predecessor` property is a 2D array of vertexMap (or `undefined`) representing the predecessor vertexMap in the shortest
     * path between vertexMap in the
     */
    floydWarshall() {
        const idAndVertices = [...this._vertexMap];
        const n = idAndVertices.length;
        const costs = [];
        const predecessor = [];
        // successors
        for (let i = 0; i < n; i++) {
            costs[i] = [];
            predecessor[i] = [];
            for (let j = 0; j < n; j++) {
                predecessor[i][j] = undefined;
            }
        }
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < n; j++) {
                costs[i][j] = this.getEdge(idAndVertices[i][1], idAndVertices[j][1])?.weight || Infinity;
            }
        }
        for (let k = 0; k < n; k++) {
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (costs[i][j] > costs[i][k] + costs[k][j]) {
                        costs[i][j] = costs[i][k] + costs[k][j];
                        predecessor[i][j] = idAndVertices[k][1];
                    }
                }
            }
        }
        return { costs, predecessor };
    }
    /**
     * Time Complexity: O(V + E) - Linear time (Tarjan's algorithm).
     * Space Complexity: O(V) - Linear space (Tarjan's algorithm).
     * Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     * Tarjan can find cycles in directed or undirected graph
     * Tarjan can find the articulation points and bridges(critical edgeMap) of undirected graphs in linear time,
     * Tarjan solve the bi-connected components of undirected graphs;
     * Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.
     * /
  
     /**
     * Time Complexity: O(V + E) - Linear time (Tarjan's algorithm).
     * Space Complexity: O(V) - Linear space (Tarjan's algorithm).
     *
     * Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     * Tarjan can find cycles in directed or undirected graph
     * Tarjan can find the articulation points and bridges(critical edgeMap) of undirected graphs in linear time,
     * Tarjan solve the bi-connected components of undirected graphs;
     * Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.
     * The `tarjan` function is used to perform various graph analysis tasks such as finding articulation points, bridges,
     * strongly connected components (SCCs), and cycles in a graph.
     * @param {boolean} [needCutVertexes] - A boolean value indicating whether or not to calculate and return the
     * articulation points in the graph. Articulation points are the vertexMap in a graph whose removal would increase the
     * number of connected components in the graph.
     * @param {boolean} [needBridges] - A boolean flag indicating whether the algorithm should find and return the bridges
     * (edgeMap whose removal would increase the number of connected components in the graph).
     * @param {boolean} [needSCCs] - A boolean value indicating whether the Strongly Connected Components (SCCs) of the
     * graph are needed. If set to true, the function will calculate and return the SCCs of the graph. If set to false, the
     * SCCs will not be calculated or returned.
     * @param {boolean} [needCycles] - A boolean flag indicating whether the algorithm should find cycles in the graph. If
     * set to true, the algorithm will return a map of cycles, where the keys are the low values of the SCCs and the values
     * are arrays of vertexMap that form cycles within the SCCs.
     * @returns The function `tarjan` returns an object with the following properties:
     */
    tarjan(needCutVertexes = false, needBridges = false, needSCCs = true, needCycles = false) {
        // !! in undirected graph we will not let child visit parent when dfs
        // !! articulation point(in dfs search tree not in graph): (cur !== root && cur.has(child)) && (low(child) >= dfn(cur)) || (cur === root && cur.children() >= 2)
        // !! bridge: low(child) > dfn(cur)
        const defaultConfig = false;
        if (needCutVertexes === undefined)
            needCutVertexes = defaultConfig;
        if (needBridges === undefined)
            needBridges = defaultConfig;
        if (needSCCs === undefined)
            needSCCs = defaultConfig;
        if (needCycles === undefined)
            needCycles = defaultConfig;
        const dfnMap = new Map();
        const lowMap = new Map();
        const vertexMap = this._vertexMap;
        vertexMap.forEach(v => {
            dfnMap.set(v, -1);
            lowMap.set(v, Infinity);
        });
        const [root] = vertexMap.values();
        const cutVertexes = [];
        const bridges = [];
        let dfn = 0;
        const dfs = (cur, parent) => {
            dfn++;
            dfnMap.set(cur, dfn);
            lowMap.set(cur, dfn);
            const neighbors = this.getNeighbors(cur);
            let childCount = 0; // child in dfs tree not child in graph
            for (const neighbor of neighbors) {
                if (neighbor !== parent) {
                    if (dfnMap.get(neighbor) === -1) {
                        childCount++;
                        dfs(neighbor, cur);
                    }
                    const childLow = lowMap.get(neighbor);
                    const curLow = lowMap.get(cur);
                    // TODO after no-non-undefined-assertion not ensure the logic
                    if (curLow !== undefined && childLow !== undefined) {
                        lowMap.set(cur, Math.min(curLow, childLow));
                    }
                    const curFromMap = dfnMap.get(cur);
                    if (childLow !== undefined && curFromMap !== undefined) {
                        if (needCutVertexes) {
                            if ((cur === root && childCount >= 2) || (cur !== root && childLow >= curFromMap)) {
                                // todo not ensure the logic if (cur === root && childCount >= 2 || ((cur !== root) && (childLow >= curFromMap))) {
                                cutVertexes.push(cur);
                            }
                        }
                        if (needBridges) {
                            if (childLow > curFromMap) {
                                const edgeCurToNeighbor = this.getEdge(cur, neighbor);
                                if (edgeCurToNeighbor) {
                                    bridges.push(edgeCurToNeighbor);
                                }
                            }
                        }
                    }
                }
            }
        };
        dfs(root, undefined);
        let SCCs = new Map();
        const getSCCs = () => {
            const SCCs = new Map();
            lowMap.forEach((low, vertex) => {
                if (!SCCs.has(low)) {
                    SCCs.set(low, [vertex]);
                }
                else {
                    SCCs.get(low)?.push(vertex);
                }
            });
            return SCCs;
        };
        if (needSCCs) {
            SCCs = getSCCs();
        }
        const cycles = new Map();
        if (needCycles) {
            const visitedMap = new Map();
            const stack = [];
            const findCyclesDFS = (cur, parent) => {
                visitedMap.set(cur, true);
                stack.push(cur);
                const neighbors = this.getNeighbors(cur);
                for (const neighbor of neighbors) {
                    if (!visitedMap.get(neighbor)) {
                        findCyclesDFS(neighbor, cur);
                    }
                    else if (stack.includes(neighbor) && neighbor !== parent) {
                        const cycleStartIndex = stack.indexOf(neighbor);
                        const cycle = stack.slice(cycleStartIndex);
                        const cycleLow = Math.min(...cycle.map(v => dfnMap.get(v) || Infinity));
                        cycles.set(cycleLow, cycle);
                    }
                }
                stack.pop();
            };
            vertexMap.forEach(v => {
                if (!visitedMap.get(v)) {
                    findCyclesDFS(v, undefined);
                }
            });
        }
        return { dfnMap, lowMap, bridges, cutVertexes, SCCs, cycles };
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Tarjan's algorithm).
     * Space Complexity: O(V) - Depends on the implementation (Tarjan's algorithm).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Tarjan's algorithm).
     * Space Complexity: O(V) - Depends on the implementation (Tarjan's algorithm).
     *
     * The function returns a map that associates each vertex object with its corresponding depth-first
     * number.
     * @returns A Map object with keys of type VO and values of type number.
     */
    getDFNMap() {
        return this.tarjan(false, false, false, false).dfnMap;
    }
    /**
     * The function returns a Map object that contains the low values of each vertex in a Tarjan
     * algorithm.
     * @returns The method `getLowMap()` is returning a `Map` object with keys of type `VO` and values of
     * type `number`.
     */
    getLowMap() {
        return this.tarjan(false, false, false, false).lowMap;
    }
    /**
     * The function `getCycles` returns a map of cycles found using the Tarjan algorithm.
     * @returns The function `getCycles()` is returning a `Map<number, VO[]>`.
     */
    getCycles() {
        return this.tarjan(false, false, false, true).cycles;
    }
    /**
     * The function "getCutVertexes" returns an array of cut vertexes using the Tarjan algorithm.
     * @returns an array of VO objects, specifically the cut vertexes.
     */
    getCutVertexes() {
        return this.tarjan(true, false, false, false).cutVertexes;
    }
    /**
     * The function "getSCCs" returns a map of strongly connected components (SCCs) using the Tarjan
     * algorithm.
     * @returns a map where the keys are numbers and the values are arrays of VO objects.
     */
    getSCCs() {
        return this.tarjan(false, false, true, false).SCCs;
    }
    /**
     * The function "getBridges" returns an array of bridges using the Tarjan algorithm.
     * @returns the bridges found using the Tarjan algorithm.
     */
    getBridges() {
        return this.tarjan(false, true, false, false).bridges;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function iterates over key-value pairs in a data structure and returns an array of
     * pairs that satisfy a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes four arguments:
     * `value`, `key`, `index`, and `this`. It is used to determine whether an element should be included
     * in the filtered array. The callback function should return `true` if the element should be
     * included, and `
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. It is used when you want to bind a
     * specific object as the context for the `predicate` function. If `thisArg` is provided, it will be
     * @returns The `filter` method returns an array of key-value pairs `[VertexKey, V | undefined][]`
     * that satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
        const filtered = [];
        let index = 0;
        for (const [key, value] of this) {
            if (predicate.call(thisArg, value, key, index, this)) {
                filtered.push([key, value]);
            }
            index++;
        }
        return filtered;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function iterates over the elements of a collection and applies a callback function to
     * each element, returning an array of the results.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * map. It takes four arguments:
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If `thisArg` is provided, it will be
     * used as the `this` value when calling the callback function. If `thisArg` is not provided, `
     * @returns The `map` function is returning an array of type `T[]`.
     */
    map(callback, thisArg) {
        const mapped = [];
        let index = 0;
        for (const [key, value] of this) {
            mapped.push(callback.call(thisArg, value, key, index, this));
            index++;
        }
        return mapped;
    }
    *_getIterator() {
        for (const vertex of this._vertexMap.values()) {
            yield [vertex.key, vertex.value];
        }
    }
    _addVertexOnly(newVertex) {
        if (this.hasVertex(newVertex)) {
            return false;
            // throw (new Error('Duplicated vertex key is not allowed'));
        }
        this._vertexMap.set(newVertex.key, newVertex);
        return true;
    }
    _getVertex(vertexOrKey) {
        const vertexKey = this._getVertexKey(vertexOrKey);
        return this._vertexMap.get(vertexKey) || undefined;
    }
    _getVertexKey(vertexOrKey) {
        return vertexOrKey instanceof AbstractVertex ? vertexOrKey.key : vertexOrKey;
    }
}
