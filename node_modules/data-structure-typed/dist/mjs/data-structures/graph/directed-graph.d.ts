/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import type { VertexKey } from '../../types';
import { AbstractEdge, AbstractGraph, AbstractVertex } from './abstract-graph';
import { IGraph } from '../../interfaces';
export declare class DirectedVertex<V = any> extends AbstractVertex<V> {
    /**
     * The constructor function initializes a vertex with an optional value.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is
     * used to uniquely identify the vertex within a graph or data structure.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It is used to initialize the value of the
     * vertex. If no value is provided, the vertex will be initialized with a default value.
     */
    constructor(key: VertexKey, value?: V);
}
export declare class DirectedEdge<E = any> extends AbstractEdge<E> {
    src: VertexKey;
    dest: VertexKey;
    /**
     * The constructor function initializes the source and destination vertexMap of an edge, along with an optional weight
     * and value.
     * @param {VertexKey} src - The `src` parameter is the source vertex ID. It represents the starting point of an edge in
     * a graph.
     * @param {VertexKey} dest - The `dest` parameter represents the destination vertex of an edge. It is of type
     * `VertexKey`, which is likely a unique identifier for a vertex in a graph.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.
     * @param {E} [value] - The `value` parameter is an optional parameter of type `E`. It represents the value associated with
     * the edge.
     */
    constructor(src: VertexKey, dest: VertexKey, weight?: number, value?: E);
}
export declare class DirectedGraph<V = any, E = any, VO extends DirectedVertex<V> = DirectedVertex<V>, EO extends DirectedEdge<E> = DirectedEdge<E>> extends AbstractGraph<V, E, VO, EO> implements IGraph<V, E, VO, EO> {
    /**
     * The constructor function initializes an instance of a class.
     */
    constructor();
    protected _outEdgeMap: Map<VO, EO[]>;
    get outEdgeMap(): Map<VO, EO[]>;
    protected _inEdgeMap: Map<VO, EO[]>;
    get inEdgeMap(): Map<VO, EO[]>;
    /**
     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.
     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.
     */
    /**
     * The function creates a new vertex with an optional value and returns it.
     * @param {VertexKey} key - The `key` parameter is the unique identifier for the vertex. It is of type `VertexKey`, which
     * could be a number or a string depending on how you want to identify your vertexMap.
     * @param [value] - The 'value' parameter is an optional value that can be assigned to the vertex. If a value is provided,
     * it will be assigned to the 'value' property of the vertex. If no value is provided, the 'value' property will be
     * assigned the same value as the 'key' parameter
     * @returns a new instance of a DirectedVertex object, casted as type VO.
     */
    createVertex(key: VertexKey, value?: V): VO;
    /**
     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.
     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.
     */
    /**
     * The function creates a directed edge between two vertexMap with an optional weight and value.
     * @param {VertexKey} src - The source vertex ID of the edge. It represents the starting point of the edge.
     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for the edge.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge. If no
     * weight is provided, it defaults to 1.
     * @param [value] - The 'value' parameter is an optional value that can be assigned to the edge. It can be of any type and
     * is used to store additional information or data associated with the edge.
     * @returns a new instance of a DirectedEdge object, casted as type EO.
     */
    createEdge(src: VertexKey, dest: VertexKey, weight?: number, value?: E): EO;
    /**
     * Time Complexity: O(|V|) where |V| is the number of vertexMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|V|) where |V| is the number of vertexMap
     * Space Complexity: O(1)
     *
     * The `getEdge` function retrieves an edge between two vertexMap based on their source and destination IDs.
     * @param {VO | VertexKey | undefined} srcOrKey - The source vertex or its ID. It can be either a vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} destOrKey - The `destOrKey` parameter in the `getEdge` function represents the
     * destination vertex of the edge. It can be either a vertex object (`VO`), a vertex ID (`VertexKey`), or `undefined` if the
     * destination is not specified.
     * @returns the first edge found between the source and destination vertexMap, or undefined if no such edge is found.
     */
    getEdge(srcOrKey: VO | VertexKey | undefined, destOrKey: VO | VertexKey | undefined): EO | undefined;
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function removes an edge between two vertexMap in a graph and returns the removed edge.
     * @param {VO | VertexKey} srcOrKey - The source vertex or its ID.
     * @param {VO | VertexKey} destOrKey - The `destOrKey` parameter represents the destination vertex or its ID.
     * @returns the removed edge (EO) if it exists, or undefined if either the source or destination vertex does not exist.
     */
    deleteEdgeSrcToDest(srcOrKey: VO | VertexKey, destOrKey: VO | VertexKey): EO | undefined;
    /**
     * Time Complexity: O(E) where E is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(E) where E is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The `deleteEdge` function removes an edge from a graph and returns the removed edge.
     * @param {EO | VertexKey} edgeOrSrcVertexKey - The `edge` parameter can be either an `EO` object (edge object) or
     * a `VertexKey` (key of a vertex).
     * @param {VertexKey} [destVertexKey] - The `destVertexKey` parameter is an optional parameter that
     * represents the key of the destination vertex of the edge. It is used to specify the destination
     * vertex when the `edge` parameter is a vertex key. If `destVertexKey` is not provided, the function
     * assumes that the `edge`
     * @returns the removed edge (EO) or undefined if no edge was removed.
     */
    deleteEdge(edgeOrSrcVertexKey: EO | VertexKey, destVertexKey?: VertexKey): EO | undefined;
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The `deleteVertex` function removes a vertex from a graph by its ID or by the vertex object itself.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method is returning a boolean value.
     */
    deleteVertex(vertexOrKey: VO | VertexKey): boolean;
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function removes edgeMap between two vertexMap and returns the removed edgeMap.
     * @param {VertexKey | VO} v1 - The parameter `v1` can be either a `VertexKey` or a `VO`. A `VertexKey` represents the
     * unique identifier of a vertex in a graph, while `VO` represents the actual vertex object.
     * @param {VertexKey | VO} v2 - The parameter `v2` represents either a `VertexKey` or a `VO` object. It is used to specify
     * the second vertex in the edge that needs to be removed.
     * @returns an array of removed edgeMap (EO[]).
     */
    deleteEdgesBetween(v1: VertexKey | VO, v2: VertexKey | VO): EO[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `incomingEdgesOf` returns an array of incoming edgeMap for a given vertex or vertex ID.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method `incomingEdgesOf` returns an array of edgeMap (`EO[]`).
     */
    incomingEdgesOf(vertexOrKey: VO | VertexKey): EO[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `outgoingEdgesOf` returns an array of outgoing edgeMap from a given vertex or vertex ID.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can accept either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method `outgoingEdgesOf` returns an array of edgeMap (`EO[]`).
     */
    outgoingEdgesOf(vertexOrKey: VO | VertexKey): EO[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "degreeOf" returns the total degree of a vertex, which is the sum of its out-degree and in-degree.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The sum of the out-degree and in-degree of the specified vertex or vertex ID.
     */
    degreeOf(vertexOrKey: VertexKey | VO): number;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "inDegreeOf" returns the number of incoming edgeMap for a given vertex.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The number of incoming edgeMap of the specified vertex or vertex ID.
     */
    inDegreeOf(vertexOrKey: VertexKey | VO): number;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `outDegreeOf` returns the number of outgoing edgeMap from a given vertex.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The number of outgoing edgeMap from the specified vertex or vertex ID.
     */
    outDegreeOf(vertexOrKey: VertexKey | VO): number;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "edgesOf" returns an array of both outgoing and incoming edgeMap of a given vertex or vertex ID.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The function `edgesOf` returns an array of edgeMap.
     */
    edgesOf(vertexOrKey: VertexKey | VO): EO[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEdgeSrc" returns the source vertex of an edge, or undefined if the edge does not exist.
     * @param {EO} e - The parameter "e" is of type EO, which represents an edge in a graph.
     * @returns either a vertex object (VO) or undefined.
     */
    getEdgeSrc(e: EO): VO | undefined;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEdgeDest" returns the destination vertex of an edge.
     * @param {EO} e - The parameter "e" is of type "EO", which represents an edge in a graph.
     * @returns either a vertex object of type VO or undefined.
     */
    getEdgeDest(e: EO): VO | undefined;
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function `getDestinations` returns an array of destination vertexMap connected to a given vertex.
     * @param {VO | VertexKey | undefined} vertex - The `vertex` parameter represents the starting vertex from which we want to
     * find the destinations. It can be either a `VO` object, a `VertexKey` value, or `undefined`.
     * @returns an array of vertexMap (VO[]).
     */
    getDestinations(vertex: VO | VertexKey | undefined): VO[];
    /**
     * Time Complexity: O(|V| + |E|) where |V| is the number of vertexMap and |E| is the number of edgeMap
     * Space Complexity: O(|V|)
     */
    /**
     * Time Complexity: O(|V| + |E|) where |V| is the number of vertexMap and |E| is the number of edgeMap
     * Space Complexity: O(|V|)
     *
     * The `topologicalSort` function performs a topological sort on a graph and returns an array of vertexMap or vertex IDs
     * in the sorted order, or undefined if the graph contains a cycle.
     * @param {'vertex' | 'key'} [propertyName] - The `propertyName` parameter is an optional parameter that specifies the
     * property to use for sorting the vertexMap. It can have two possible values: 'vertex' or 'key'. If 'vertex' is
     * specified, the vertexMap themselves will be used for sorting. If 'key' is specified, the ids of
     * @returns an array of vertexMap or vertex IDs in topological order. If there is a cycle in the graph, it returns undefined.
     */
    topologicalSort(propertyName?: 'vertex' | 'key'): Array<VO | VertexKey> | undefined;
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(|E|)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(|E|)
     *
     * The `edgeSet` function returns an array of all the edgeMap in the graph.
     * @returns The `edgeSet()` method returns an array of edgeMap (`EO[]`).
     */
    edgeSet(): EO[];
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function `getNeighbors` returns an array of neighboring vertexMap of a given vertex or vertex ID in a graph.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns an array of vertexMap (VO[]).
     */
    getNeighbors(vertexOrKey: VO | VertexKey): VO[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEndsOfEdge" returns the source and destination vertexMap of an edge if it exists in the graph,
     * otherwise it returns undefined.
     * @param {EO} edge - The parameter `edge` is of type `EO`, which represents an edge in a graph.
     * @returns The function `getEndsOfEdge` returns an array containing two vertexMap `[VO, VO]` if the edge exists in the
     * graph. If the edge does not exist, it returns `undefined`.
     */
    getEndsOfEdge(edge: EO): [VO, VO] | undefined;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_addEdgeOnly` adds an edge to a graph if the source and destination vertexMap exist.
     * @param {EO} edge - The parameter `edge` is of type `EO`, which represents an edge in a graph. It is the edge that
     * needs to be added to the graph.
     * @returns a boolean value. It returns true if the edge was successfully added to the graph, and false if either the
     * source or destination vertex does not exist in the graph.
     */
    protected _addEdgeOnly(edge: EO): boolean;
}
