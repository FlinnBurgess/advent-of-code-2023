/**
 * data-structure-typed
 * @author Kirk Qi
 * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>
 * @license MIT License
 */
import type { Comparator, DFSOrderPattern, ElementCallback, HeapOptions } from '../../types';
import { IterableElementBase } from '../base';
/**
 * 1. Complete Binary Tree: Heaps are typically complete binary trees, meaning every level is fully filled except possibly for the last level, which has nodes as far left as possible.
 * 2. Heap Properties: Each node in a heap follows a specific order property, which varies depending on the type of heap:
 * Max Heap: The value of each parent node is greater than or equal to the value of its children.
 * Min Heap: The value of each parent node is less than or equal to the value of its children.
 * 3. Root Node Access: In a heap, the largest element (in a max heap) or the smallest element (in a min heap) is always at the root of the tree.
 * 4. Efficient Insertion and Deletion: Due to its structure, a heap allows for insertion and deletion operations in logarithmic time (O(log n)).
 * 5. Managing Dynamic Data Sets: Heaps effectively manage dynamic data sets, especially when frequent access to the largest or smallest elements is required.
 * 6. Non-linear Search: While a heap allows rapid access to its largest or smallest element, it is less efficient for other operations, such as searching for a specific element, as it is not designed for these tasks.
 * 7. Efficient Sorting Algorithms: For example, heap sort. Heap sort uses the properties of a heap to sort elements.
 * 8. Graph Algorithms: Such as Dijkstra's shortest path algorithm and Prim's minimum spanning tree algorithm, which use heaps to improve performance.
 */
export declare class Heap<E = any> extends IterableElementBase<E> {
    options: HeapOptions<E>;
    constructor(elements?: Iterable<E>, options?: HeapOptions<E>);
    protected _elements: E[];
    get elements(): E[];
    /**
     * Get the size (number of elements) of the heap.
     */
    get size(): number;
    /**
     * Get the last element in the heap, which is not necessarily a leaf node.
     * @returns The last element or undefined if the heap is empty.
     */
    get leaf(): E | undefined;
    /**
     * Static method that creates a binary heap from an array of elements and a comparison function.
     * @returns A new Heap instance.
     * @param elements
     * @param options
     */
    static heapify<E>(elements: Iterable<E>, options: {
        comparator: Comparator<E>;
    }): Heap<E>;
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element - The element to be inserted.
     */
    add(element: E): boolean;
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     *
     * Remove and return the top element (smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    poll(): E | undefined;
    /**
     * Peek at the top element of the heap without removing it.
     * @returns The top element or undefined if the heap is empty.
     */
    peek(): E | undefined;
    /**
     * Check if the heap is empty.
     * @returns True if the heap is empty, otherwise false.
     */
    isEmpty(): boolean;
    /**
     * Reset the elements of the heap. Make the elements empty.
     */
    clear(): void;
    /**
     * Time Complexity: O(n), where n is the number of elements in the elements array.
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n), where n is the number of elements in the elements array.
     * Space Complexity: O(n)
     *
     * Clear and add elements of the heap
     * @param elements
     */
    refill(elements: E[]): boolean[];
    /**
     * Time Complexity: O(n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     *
     * Use a comparison function to check whether a binary heap contains a specific element.
     * @param element - the element to check.
     * @returns Returns true if the specified element is contained; otherwise, returns false.
     */
    has(element: E): boolean;
    /**
     * Time Complexity:  O(n). The worst-case  O(n), where n is the number of elements in the heap. This is because, in the worst case, the element to be deleted is located at the end of the heap (not the root), and after deletion, we may need to reorganize the elements by performing a sinkDown operation.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity:  O(n). The worst-case  O(n), where n is the number of elements in the heap. This is because, in the worst case, the element to be deleted is located at the end of the heap (not the root), and after deletion, we may need to reorganize the elements by performing a sinkDown operation.
     * Space Complexity: O(1)
     *
     * The `delete` function removes an element from an array-like data structure, maintaining the order
     * and structure of the remaining elements.
     * @param {E} element - The `element` parameter represents the element that you want to delete from
     * the array `this.elements`.
     * @returns The `delete` function is returning a boolean value. It returns `true` if the element was
     * successfully deleted from the array, and `false` if the element was not found in the array.
     */
    delete(element: E): boolean;
    /**
     * Time Complexity: O(n), where n is the number of elements in the heap.
     * Space Complexity: O(h), where h is the height of the heap.
     */
    /**
     * Time Complexity: O(n), where n is the number of elements in the heap.
     * Space Complexity: O(h), where h is the height of the heap.
     *
     * Depth-first search (DFS) method, different traversal orders can be selectedã€‚
     * @param order - Traverse order parameter: 'in' (in-order), 'pre' (pre-order) or 'post' (post-order).
     * @returns An array containing elements traversed in the specified order.
     */
    dfs(order?: DFSOrderPattern): E[];
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Convert the heap to an array.
     * @returns An array containing the elements of the heap.
     */
    toArray(): E[];
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Clone the heap, creating a new heap with the same elements.
     * @returns A new Heap instance containing the same elements.
     */
    clone(): Heap<E>;
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * Sort the elements in the heap and return them as an array.
     * @returns An array containing the elements sorted in ascending order.
     */
    sort(): E[];
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * Fix the entire heap to maintain heap properties.
     */
    fix(): boolean[];
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new Heap object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `Heap` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback: ElementCallback<E, boolean>, thisArg?: any): Heap<E>;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * original heap. It takes three arguments: the current element, the index of the current element,
     * and the original heap itself. The callback function should return a value of type T, which will be
     * added to the mapped heap.
     * @param comparator - The `comparator` parameter is a function that is used to compare elements in
     * the heap. It takes two arguments, `a` and `b`, and returns a negative number if `a` is less than
     * `b`, a positive number if `a` is greater than `b`, or
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used when you want to bind a
     * specific object as the context for the callback function. If `thisArg` is not provided,
     * `undefined` is used as
     * @returns a new instance of the Heap class, which is created using the mapped elements from the
     * original Heap.
     */
    map<T>(callback: ElementCallback<E, T>, comparator: Comparator<T>, thisArg?: any): Heap<T>;
    protected _getIterator(): IterableIterator<E>;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Float operation to maintain heap properties after adding an element.
     * @param index - The index of the newly added element.
     */
    protected _bubbleUp(index: number): boolean;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Sinking operation to maintain heap properties after removing the top element.
     * @param index - The index from which to start sinking.
     * @param halfLength
     */
    protected _sinkDown(index: number, halfLength: number): boolean;
}
export declare class FibonacciHeapNode<E> {
    element: E;
    degree: number;
    left?: FibonacciHeapNode<E>;
    right?: FibonacciHeapNode<E>;
    child?: FibonacciHeapNode<E>;
    parent?: FibonacciHeapNode<E>;
    marked: boolean;
    constructor(element: E, degree?: number);
}
export declare class FibonacciHeap<E> {
    constructor(comparator?: Comparator<E>);
    protected _root?: FibonacciHeapNode<E>;
    get root(): FibonacciHeapNode<E> | undefined;
    protected _size: number;
    get size(): number;
    protected _min?: FibonacciHeapNode<E>;
    get min(): FibonacciHeapNode<E> | undefined;
    protected _comparator: Comparator<E>;
    get comparator(): Comparator<E>;
    /**
     * Get the size (number of elements) of the heap.
     * @returns {number} The size of the heap.  Returns 0 if the heap is empty. Returns -1 if the heap is invalid.
     */
    clear(): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element
     * @returns {FibonacciHeap<E>} FibonacciHeap<E> - The heap itself.
     */
    add(element: E): FibonacciHeap<E>;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element
     * @returns {FibonacciHeap<E>} FibonacciHeap<E> - The heap itself.
     */
    push(element: E): FibonacciHeap<E>;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Peek at the top element of the heap without removing it.
     * @returns The top element or undefined if the heap is empty.
     * @protected
     */
    peek(): E | undefined;
    /**
     * Time Complexity: O(n), where n is the number of elements in the linked list.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n), where n is the number of elements in the linked list.
     * Space Complexity: O(1)
     *
     * Get the size (number of elements) of the heap.
     * @param {FibonacciHeapNode<E>} head - The head of the linked list.
     * @protected
     * @returns FibonacciHeapNode<E>[] - An array containing the elements of the linked list.
     */
    consumeLinkedList(head?: FibonacciHeapNode<E>): FibonacciHeapNode<E>[];
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * @param parent
     * @param node
     */
    mergeWithChild(parent: FibonacciHeapNode<E>, node: FibonacciHeapNode<E>): void;
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     *
     * Remove and return the top element (smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    poll(): E | undefined;
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n), where n is the number of elements in the heap.
     * Space Complexity: O(1)
     *
     * Remove and return the top element (smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    pop(): E | undefined;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * merge two heaps. The heap that is merged will be cleared. The heap that is merged into will remain.
     * @param heapToMerge
     */
    merge(heapToMerge: FibonacciHeap<E>): void;
    /**
     * Create a new node.
     * @param element
     * @protected
     */
    createNode(element: E): FibonacciHeapNode<E>;
    /**
     * Default comparator function used by the heap.
     * @param {E} a
     * @param {E} b
     * @protected
     */
    protected _defaultComparator(a: E, b: E): number;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Merge the given node with the root list.
     * @param node - The node to be merged.
     */
    protected mergeWithRoot(node: FibonacciHeapNode<E>): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *.
     * Remove and return the top element (smallest or largest element) from the heap.
     * @param node - The node to be removed.
     * @protected
     */
    protected removeFromRoot(node: FibonacciHeapNode<E>): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (smallest or largest element) from the heap.
     * @param y
     * @param x
     * @protected
     */
    protected _link(y: FibonacciHeapNode<E>, x: FibonacciHeapNode<E>): void;
    /**
     * Time Complexity: O(n log n), where n is the number of elements in the heap.
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n log n), where n is the number of elements in the heap.
     * Space Complexity: O(n)
     *
     * Remove and return the top element (smallest or largest element) from the heap.
     * @protected
     */
    protected _consolidate(): void;
}
