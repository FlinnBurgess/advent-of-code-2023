"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcMinUnitsRequired = exports.isWeakKey = exports.throwRangeError = exports.rangeCheck = exports.getMSB = exports.trampolineAsync = exports.trampoline = exports.toThunk = exports.isThunk = exports.THUNK_SYMBOL = exports.arrayRemove = exports.uuidV4 = void 0;
const uuidV4 = function () {
    return 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.replace(/[x]/g, function (c) {
        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
};
exports.uuidV4 = uuidV4;
const arrayRemove = function (array, predicate) {
    let i = -1, len = array ? array.length : 0;
    const result = [];
    while (++i < len) {
        const value = array[i];
        if (predicate(value, i, array)) {
            result.push(value);
            Array.prototype.splice.call(array, i--, 1);
            len--;
        }
    }
    return result;
};
exports.arrayRemove = arrayRemove;
exports.THUNK_SYMBOL = Symbol('thunk');
const isThunk = (fnOrValue) => {
    return typeof fnOrValue === 'function' && fnOrValue.__THUNK__ === exports.THUNK_SYMBOL;
};
exports.isThunk = isThunk;
const toThunk = (fn) => {
    const thunk = () => fn();
    thunk.__THUNK__ = exports.THUNK_SYMBOL;
    return thunk;
};
exports.toThunk = toThunk;
const trampoline = (fn) => {
    const cont = (...args) => (0, exports.toThunk)(() => fn(...args));
    return Object.assign((...args) => {
        let result = fn(...args);
        while ((0, exports.isThunk)(result) && typeof result === 'function') {
            result = result();
        }
        return result;
    }, { cont });
};
exports.trampoline = trampoline;
const trampolineAsync = (fn) => {
    const cont = (...args) => (0, exports.toThunk)(() => fn(...args));
    return Object.assign((...args) => __awaiter(void 0, void 0, void 0, function* () {
        let result = yield fn(...args);
        while ((0, exports.isThunk)(result) && typeof result === 'function') {
            result = yield result();
        }
        return result;
    }), { cont });
};
exports.trampolineAsync = trampolineAsync;
const getMSB = (value) => {
    if (value <= 0) {
        return 0;
    }
    return 1 << (31 - Math.clz32(value));
};
exports.getMSB = getMSB;
const rangeCheck = (index, min, max, message = 'Index out of bounds.') => {
    if (index < min || index > max)
        throw new RangeError(message);
};
exports.rangeCheck = rangeCheck;
const throwRangeError = (message = 'The value is off-limits.') => {
    throw new RangeError(message);
};
exports.throwRangeError = throwRangeError;
const isWeakKey = (input) => {
    const inputType = typeof input;
    return (inputType === 'object' && input !== null) || inputType === 'function';
};
exports.isWeakKey = isWeakKey;
const calcMinUnitsRequired = (totalQuantity, unitSize) => Math.floor((totalQuantity + unitSize - 1) / unitSize);
exports.calcMinUnitsRequired = calcMinUnitsRequired;
