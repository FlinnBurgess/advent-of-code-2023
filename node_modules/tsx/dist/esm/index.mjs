import{isMainThread as O}from"worker_threads";import{i as M,s as v}from"../node-features-6a939068.mjs";import F from"module";import{installSourceMapSupport as w}from"../source-map.mjs";import f from"path";import{fileURLToPath as _,pathToFileURL as N}from"url";import{b as U,t as D}from"../index-bd1ceb03.mjs";import{r as A}from"../resolve-ts-path-eb3847f5.mjs";import{c as J}from"../client-e665d820.mjs";import{parseTsconfig as b,getTsconfig as x,createFilesMatcher as I,createPathsMatcher as L}from"get-tsconfig";import P from"fs";import"esbuild";import"crypto";import"os";import"../temporary-directory-04b36185.mjs";import"net";import"../get-pipe-path-b74d9893.mjs";const $=()=>{w(),F.register("./index.mjs",{parentURL:import.meta.url,data:!0})},p=new Map;async function C(t){if(p.has(t))return p.get(t);if(!await P.promises.access(t).then(()=>!0,()=>!1)){p.set(t,void 0);return}const o=await P.promises.readFile(t,"utf8");try{const e=JSON.parse(o);return p.set(t,e),e}catch{throw new Error(`Error parsing: ${t}`)}}async function W(t){let r=new URL("package.json",t);for(;!r.pathname.endsWith("/node_modules/package.json");){const o=_(r),e=await C(o);if(e)return e;const a=r;if(r=new URL("../package.json",r),r.pathname===a.pathname)break}}async function q(t){var r;const o=await W(t);return(r=o==null?void 0:o.type)!=null?r:"commonjs"}const u=process.env.TSX_TSCONFIG_PATH?{path:f.resolve(process.env.TSX_TSCONFIG_PATH),config:b(process.env.TSX_TSCONFIG_PATH)}:x(),G=u&&I(u),T=u&&L(u),E="file://",h=/\.([cm]?ts|[tj]sx)($|\?)/,H=/\.json(?:$|\?)/,X=t=>{const r=f.extname(t);if(r===".json")return"json";if(r===".mjs"||r===".mts")return"module";if(r===".cjs"||r===".cts")return"commonjs"},K=t=>{const r=X(t);if(r)return r;if(h.test(t))return q(t)},k=w(),R=/\/(?:$|\?)/,Q=async t=>{if(!t)throw new Error(`tsx must be loaded with --import instead of --loader
The --loader flag was deprecated in Node v20.6.0 and v18.19.0`)},z=()=>`
const require = getBuiltin('module').createRequire("${import.meta.url}");
require('../source-map.cjs').installSourceMapSupport();
`,d=async(t,r,o)=>{const e=await t(r,o);return!e.format&&e.url.startsWith(E)&&(e.format=await K(e.url)),e},B=[".js",".json",".ts",".tsx",".jsx"];async function l(t,r,o){const[e,a]=t.split("?");let c;for(const n of B)try{return await d(o,e+n+(a?`?${a}`:""),r)}catch(s){if(c===void 0&&s instanceof Error){const{message:i}=s;s.message=s.message.replace(`${n}'`,"'"),s.stack=s.stack.replace(i,s.message),c=s}}throw c}async function j(t,r,o){const e=R.test(t),a=e?"index":"/index",[c,n]=t.split("?");try{return await l(c+a+(n?`?${n}`:""),r,o)}catch(s){if(!e)try{return await l(t,r,o)}catch{}const i=s,{message:m}=i;throw i.message=i.message.replace(`${a.replace("/",f.sep)}'`,"'"),i.stack=i.stack.replace(m,i.message),i}}const V=/^\.{1,2}\//,S=async function(t,r,o,e){var a;if(R.test(t))return await j(t,r,o);const c=t.startsWith(E)||V.test(t);if(T&&!c&&!((a=r.parentURL)!=null&&a.includes("/node_modules/"))){const n=T(t);for(const s of n)try{return await S(N(s).toString(),r,o)}catch{}}if(h.test(r.parentURL)){const n=A(t);if(n)for(const s of n)try{return await d(o,s,r)}catch(i){const{code:m}=i;if(m!=="ERR_MODULE_NOT_FOUND"&&m!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw i}}try{return await d(o,t,r)}catch(n){if(n instanceof Error&&!e){const{code:s}=n;if(s==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await j(t,r,o)}catch(i){if(i.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw i}if(s==="ERR_MODULE_NOT_FOUND")try{return await l(t,r,o)}catch{}}throw n}};let g;J.then(t=>{g=t},()=>{});const y=M?"importAttributes":"importAssertions",Y=async function(t,r,o){var e;g&&g({type:"dependency",path:t}),H.test(t)&&(r[y]||(r[y]={}),r[y].type="json");const a=await o(t,r);if(!a.source)return a;const c=t.startsWith("file://")?_(t):t,n=a.source.toString();if(a.format==="json"||h.test(t)){const s=await U(n,c,{tsconfigRaw:(e=G)==null?void 0:e(c)});return{format:"module",source:k(s)}}if(a.format==="module"){const s=D(c,n);s&&(a.source=k(s))}return a};v&&O&&$();export{z as globalPreload,Q as initialize,Y as load,S as resolve};
